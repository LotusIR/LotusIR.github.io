[{"title":"素数相关","date":"2019-07-02T11:00:44.000Z","path":"2019/07/02/prime/","text":"素数素数，就是因数只有1和自己的数，本文将介绍一些素数相关的内容。 素数筛一种快速找出一定范围内所有素数的方法。 埃拉托斯特尼筛法简称埃氏筛或埃筛，是一种十分好写也十分容易理解的素数筛法。原理十分简单，如果一个数是素数，那么他的任意倍数一定不是素数。因此我们首先假设所有数都是素数，接着从2开始找，2是素数，那么把它的所有倍数标记为非素数，从小到大开始筛，这样当我们找到一个数还没有被标记为非素数的话，它一定是一个素数，再次标记它的所有倍数为非素数，依此循环。下面给出代码： 123456789101112131415161718#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 4e3;//只筛到maxn以内的质数using namespace std;int is_prime[maxn],prime[maxn];void getprime()&#123; for(int i = 1; i &lt;= maxn) is_prime[i] = 1; int cnt = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(is_prime[i])&#123; prime[cnt++] = i; for(int j = i + i; j &lt;= maxn; j+=i) is_prime[j] = 0; &#125; &#125;&#125; 欧拉筛法又名快速素数筛或欧筛，一听名字就知道它很快。那么为什么欧拉筛法比埃氏筛快呢，或者说，埃氏筛法哪里慢了？观察埃氏筛法，我们发现，同一个合数，它有可能被多个素数筛到，比如6被2筛到之后又会被3筛到，这就造成了多余的运算。而欧拉筛避免了这一点，在欧拉筛中每一个合数都只会被筛到一次，实现了线性复杂度O(n)。证明略，直接给出代码实现： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e6;using namespace std;int not_prime[maxn],prime[maxn];void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; j&lt;tot &amp;&amp; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125; 相较于埃氏筛，欧拉筛法更快，且没有其他缺点，因此实际上只要记住欧拉筛就可以了埃氏筛比较好记就是了 分解素因数将一个大合数N分解成素因数的乘积，方法如下：1.用欧拉筛或埃氏筛得到素数表。2.从素数表中最小的素数P开始，如果N能够被P整除，那么将N /= P，并将作为素因数的指数加一，重复这个步骤直到N不能被P整除。3.用下一个较大的素数重复第2步，直到取出大于$sqrt(N)$的第一个素数。4.如果N已经被除到了1，那么素因数分解完毕，如果N还没有被除到1，那么N最终的值是它自己的最后一个素因数。 用途较少，这里给出一道可用这种方法解答的例题：SHUOJ2只能用校内网连上，连不上就算了。。题意简述：给定正整数A,B（1&lt;=A,B&lt;=1000）,求$GCD(A,B^B)$。解题思路：由于B较大，显然不能直接求出$B^B$再求GCD，因此对A和B进行素因数分解，再将B的每一个素因数的指数乘以B，就能得出$B^B$的素因数，A和B的公共素因数的乘积就是所求的答案。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e3;using namespace std;int not_prime[maxn],prime[maxn],cnt[2][1500],A,B;void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; j&lt;tot &amp;&amp; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;//快速幂int qpow(int x,int y)&#123; int res = 1; while(y)&#123; if(y&amp;1) res = res * x; y &gt;&gt;= 1; x = x * x; &#125; return res;&#125;int main()&#123; getprime(); while(cin &gt;&gt; A &gt;&gt; B)&#123; memset(cnt,0,sizeof(cnt)); int t = B; for(int i = 0; i &lt;= 30; i++)&#123; while(A % prime[i] == 0)&#123;cnt[0][i]++;A /= prime[i];&#125; while(B % prime[i] == 0)&#123;cnt[1][i]++;B /= prime[i];&#125; cnt[1][i] *= t; &#125; int ans = 1; for(int i = 0; i &lt;= 30; i++)&#123; ans *= qpow(prime[i],min(cnt[0][i],cnt[1][i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 本题还有另一种做法直接用公式求解但我不会公式，之后会补上。此外，有一件很奇怪的事就是当maxn取某些值的时候，prime[0]会莫名其妙变成1，暂时没有发现原因。。 后记素数相关的算法和思想还是比较重要的，HDU的多校赛经常出现GCD等相关问题。今天的训练赛打的真是自闭","tags":[{"name":"素数筛","slug":"素数筛","permalink":"https://lotusir.github.io/tags/素数筛/"},{"name":"分解因数","slug":"分解因数","permalink":"https://lotusir.github.io/tags/分解因数/"},{"name":"素数","slug":"素数","permalink":"https://lotusir.github.io/tags/素数/"}]},{"title":"ACM暑期训练赛（HDU07）","date":"2019-07-02T08:04:58.000Z","path":"2019/07/02/HDU07/","text":"2019/07/02 阴有雨 比赛地址：HDU07 HDU07A All Kill（待补） B Build a Tree题意：给出一棵有N个节点的完全K叉树，求这棵树所有子树大小异或后的答案。解题：待补，考虑将子树分为完整的K叉树和不完整的K叉树，不完整的k叉树至多只有一棵，单独处理这棵树，从树的最底层向上递归求解。 C Color the chessboard题意：给出一张矩形图，图上每一个单位矩形初始状态下被涂为白色或红色或蓝色，现在要将这张图上的每一个白色的单位矩形染上色，要求所有具有偶数行数和偶数列数的矩形中所含有的蓝色矩形和红色矩形数量相等。解题：待补，显然只要所有的2*2的矩形都满足条件，那么就能满足条件，DFS or DP？ D Destroy the cube(待补) E Euler theorem题意：给出若干个整数，对于每一个整数，要求输出这个整数余除以任意一个数能得到的余数的个数。（如，对于3，3%3=0,3%4=3,3%2=1,任何数都不能让3余2，因此有3个余数）。解题：签到题打表就能得到答案。显然，对于一个数N，任何数不可能让它余超过$(N-1)/2$，而任意不超过N/2的余数都是有可能得到的，因此最终的答案就是$N/2+2$(1~N/2以及0和N)。简单证明：要让$N$余一个数$m$，只要让他余除$N-m$就可以了，但当$m&gt;(N-1)/2$时$2(N-m)&lt;N+1$,即$2(N-m)&lt;=N$,这时$N$余除$(N-m)$的值就变成了$N$余除$2(N-m)$的值，显然这是一个小于$(N-1)/2$的值。 F Free from square题意：给出两个整数n,K（小于500），要求从1 ~ K中挑出n个整数，这些整数的乘积不能被任何完全平方数（除了1）整除，输出可行的方案数。解题：待补，显然不能选相同的数字，且选了一个数以后不能再选任何它的倍数。然后不会了 G Give out candies（待补） H Hard challenge题意：在二维坐标平面上给出若干个点的坐标和权值，保证任意两点所连成的直线不经过原点，任意两点间的边的权值等于这两点权值的乘积，现在要求过原点画一条直线，这条直线所穿过的边的权值之和最大，输出最大的权值。解题：代码待补1.首先，任何一条过原点的直线所穿过的边的权值之和，等于直线一边所有点的权值之和乘以直线另一边所有点的权值之和。2.根据原点到每一个点连线的斜率，可以将所画直线的斜率分成若干个区间，枚举这些区间就能得出答案。3.为了得到区间，首先需要将点按照斜率的不同进行排序（极序排序），接着按照第0个点到第1个点间，第1个点到第2个点间……的顺序进行枚举。4.可以在0 ~ 360°的区间内维护一个前缀和快速得出某一直线两边的点的权值之和。 I Inverse of sum（待补） J Just do it题意：给出一个数列a0a1a2……an，要求进行一种运算m次，这种运算就是将每一个ai变成bi，切bi的值等于原数列ai从a0异或到ai的结果。解题：待补，找规律？我找了个规律然后T了(┬＿┬) K Kolakoski题意：有一种特殊的数列，它的第一项是1，这个数列形如：1，2，2，1，1，2，1，2，2……，将这个数列相同的项合并会变成1，22，11，2，1，22……，计算每一项的位数作为新数列这一项的值会变成1，2，2，1，1，2……，我们发现这个数列变回了最初的数列，现在要求输出这个数列的第n项（n&lt;1e7）。解题：n的数值较小，直接用vector暴力模拟即可。简述模拟过程：1.首先初始化数列的前3项为1，2，22.接着将指针指向第3项（2）。3.沿着指针，如果发现了一个2，那么需要在队尾添加两个相同的数，但这个数要与前一个数不同，因此如果此时队尾元素是1那么push_back两个2，如果队尾元素是2那么push_back两个1；如果发现了一个1，那么push_back一个与队尾元素不同的数即可。贴上AC的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; s;int main()&#123; int t,temp; //模拟过程 s.push_back(1); s.push_back(2); s.push_back(2); for(int i=2;i&lt;1e7+5;i++) &#123; temp = s.size() - 1; if(s[i] == 1) &#123; if(s[temp] == 1) &#123; s.push_back(2); &#125; else &#123; s.push_back(1); &#125; &#125; else &#123; if(s[temp] == 2) &#123; s.push_back(1); s.push_back(1); &#125; else &#123; s.push_back(2); s.push_back(2); &#125; &#125; &#125; //模拟结束 cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; cout&lt;&lt;s[n-1]&lt;&lt;endl; &#125;&#125; L Loop next（待补） M Mystery（待补） 看看明天能补几道吧。。(┬＿┬) 补题日记","tags":[{"name":"自闭","slug":"自闭","permalink":"https://lotusir.github.io/tags/自闭/"}]},{"title":"图论最小生成树","date":"2019-07-02T03:36:55.000Z","path":"2019/07/02/minTree/","text":"最小生成树本文会介绍两种用于获取最小生成树的算法，同样只给出用法不给出证明。 引入最小生成树通常用于解决形如以下的这种问题：给定若干个点和若干个边，保证这些边能将这些点全联通，试从这些边中选出部分边，使生成的树的边权之和最小。当然ACM的题通常都会有一个场景，比如有许多城镇，现已知这些城镇间的距离，要在这些城镇间修路，保证联通所有城镇的同时使得所修的路最短。 最小生成树算法下文会介绍两种算法Prim和Kruscal算法,这两种算法都会采用贪心的策略。 PrimPrim是一种以点为主体的贪心算法。下面简述算法的过程：1.在所有点中任取一点作为树的根，更新其他所有点到树的距离。2.在未被选取的点中，找到离树最近的点并选入树中，再次更新其他所有点到树的距离。3.重复第2步，直到所有点都被选入树中，Prim算法到此结束。点到树的距离是指点到树上任意一点的最短距离注意给出的图有多个最小生成树，根据选取的起点不同可能的到不同的最小生成树，但如果最小生成树唯一，那么起点的选取不会影响最终得到的最小生成树，所以放心大胆地去选取起点吧！ 下面给出prim算法主体的代码： 123456789101112131415161718192021222324void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125; 本算法中采用邻接矩阵以及暴力遍历找最小值的方式实现，理论上可以用优先队列和邻接表实现。 同样给出例题：hdu1233以下是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn = 200;const int inf = 0x3f3f3f3f;using namespace std;int N,dis[maxn][maxn],vis[maxn],ans,mndis[maxn];void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; N)&#123; if(!N) break; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); int T = N * (N - 1) / 2; while(T--)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; dis[a][b] = dis[b][a] = c; &#125; prim(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; KruscalKruscal是一种以边为主体的贪心算法，下面简述算法过程。1.从所有没有使用过的边中找出最短的一条边，标记为使用过了。2.如果边的两个端点不在一棵树中，那么将这条边加入到树中，否则不加入。3.重复1、2步直到所有点被联通（显然联通n个点需要n-1条边）。 找最短边的过程可以用优先队列实现，而判断端点是否在同一棵树中，可以用并查集实现，本文不对并查集做介绍，会在将来的文章中单独介绍。下面给出Kruscal算法的主体代码： 12345678910111213141516171819void kruscal()&#123; int ans = 0,cnt = 0; //选取最短边直到没有边可以再选或者图已经联通 while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; //利用并查集判断是否在同一棵树中，如果不在则加入树中 if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; //没有选取到M-1条边（M为点的数量），说明图不能联通 if(cnt != M-1) puts(\"?\"); //图已联通，输出最小边权和 else printf(\"%d\\n\",ans);&#125; 同样给出例题：hdu1683AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;const int maxn = 200;using namespace std;struct edge&#123; int from; int to; int val; edge(int a = 0,int b = 0,int c = 0)&#123;from=a;to=b;val=c;&#125; friend bool operator &gt; (edge a,edge b)&#123; return a.val &gt; b.val; &#125;&#125;;int N,M,father[maxn];priority_queue&lt; edge,vector&lt;edge&gt;,greater&lt;edge&gt; &gt; Q;int Find(int a)&#123; if(father[a]==a) return a; return father[a]=Find(father[a]);&#125;void Union(int a,int b)&#123; int f1=Find(a),f2=Find(b); father[f2] = f1;&#125;void init()&#123; for(int i = 1; i &lt;= M; ++i) father[i]=i; while(!Q.empty()) Q.pop();&#125;void kruscal()&#123; int ans = 0,cnt = 0; while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; if(cnt != M-1) puts(\"?\"); else printf(\"%d\\n\",ans);&#125;int main()&#123; while(scanf(\"%d\",&amp;N))&#123; if(N==0) break; scanf(\"%d\",&amp;M); init(); for(int i = 0; i &lt; N; i++)&#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); Q.push(edge(a,b,c)); &#125; if(N&lt;M-1)&#123;puts(\"?\");continue;&#125; kruscal(); &#125; return 0;&#125; 后记以上就是两种最短路算法的实现过程了。后记不知道写啥了，就这样吧","tags":[{"name":"贪心","slug":"贪心","permalink":"https://lotusir.github.io/tags/贪心/"},{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://lotusir.github.io/tags/最小生成树/"}]},{"title":"图论最短路","date":"2019-07-01T14:40:31.000Z","path":"2019/07/01/minpath/","text":"最短路算法本文将介绍几种用于解决最短路问题的算法，仅给出用法，不给出证明（因为不会证明）。 问题简述最短路问题：给出若干个点和若干个带有边权的边，要求找出从某点到某点的最短路径。 邻接表简单来说就是为每一个点建立一个边链表记录了与这个点所连的所有边。实现方法很多，本文用vector实现。 123//edge为边的结构体，maxn为点的总数，E[i]中记录了与点i相连的所有边//如果题目为无向图，注意要push_back两个方向的边vector&lt;edge&gt; E[maxn]; 单源最短路即仅要求求出从一个点到其他所有点（某一点）的最短距离的问题。 dijkstra我将dijkstra认识为一个贪心的BFS过程，首先，我们需要用到两个结构体。1.边，这个结构体必须包含目标点，边权，可以包含出发点（也可以不包含）。 12345struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;; 2.状态，这个结构体需要包含当前所在的位置（影响联通路径的状态）和已经走过的距离，同时重载&gt;号，比较的依据为走过的距离，重载&gt;号是为了能够使用priority_queue。 123456789struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;; 有了这两个结构体之后，我们就能开始dijkstra的主体了，简单地描述一下dijkstra的过程。1.录入数据。2.创建一个nod的优先队列，从小的开始出队列。3.将初始态（初始位置，经过的距离为0）push进优先队列，设初始最短路径都为无穷大。4.弹出队首元素，更新与队首位置相连的所有点，如果能够更新（距离变小了）某个点，则将这个点push进队列。5.重复第4步直到队列为空，这意味着没有点能够再次被更新了，dijkstra算法到此结束。下面给出算法主体代码： 12345678910111213141516171819202122232425void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; //优先队列，从较小的开始出 Q.push(nod(N,0));//初始态,N为出发点 //类似BFS过程 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; //若能更新，则更新并把更新的点push进队列 if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125; 需要注意的是，dijkstra算法并不能判断负环，因此当题目中出现负边时慎用。 这里给出一道例题：POJ2387AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int maxn = 1000+50;const int inf = 0x3f3f3f3f;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];int T,N,dis[maxn];//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....//加边，无向图时添加两条边void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); return;&#125;void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(N,0));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T &gt;&gt; N; while(T--)&#123; int from,to,val; cin &gt;&gt; from &gt;&gt; to &gt;&gt; val; add(from,to,val); &#125; dij(); cout &lt;&lt; dis[1] &lt;&lt; endl; return 0;&#125; 以下内容较难，可跳过此外，虽然在上题中dis[i]表示从起点到i点的最短距离，但实际上这个dis数组的下标代表的是一个状态，本题中状态只有所在的点，因此dis数组也只需要一个下标，dis数组的下标可以根据需要扩充。例如在hdu6071中，dis[i][j]表示的就是跑到了i点且跑过的距离模mod后为j的一个状态，我们也可以将每一种状态抽象为不同的点。同样给出AC代码（本题较难，可能另开文章单独解释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 6e5+20;const int mod = 998244353;const int inf = 0x3f3f3f3f;const ll llinf = 0x3f3f3f3f3f3f3f3f;using namespace std;struct edge&#123; ll from; ll to; ll val; edge(ll a = 0,ll b = 0,ll c = 0)&#123;from=a;to=b;val=c;&#125;&#125;;struct nod&#123; ll pos; ll d; nod(ll a=0,ll b=0)&#123;pos = a;d = b;&#125; friend bool operator &gt; (nod a,nod b)&#123; return a.d &gt; b.d; &#125;&#125;;ll T,k,d12,d23,d34,d41,m,dis[5][maxn];vector&lt;edge&gt; E[5];void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(2,0)); while(!Q.empty())&#123; nod t = Q.top(); Q.pop(); if(t.d &gt; dis[t.pos][t.d%m]) continue; for(vector&lt;edge&gt;::iterator it = E[t.pos].begin(); it != E[t.pos].end(); it++)&#123; ll nd = t.d+(*it).val; if(nd &lt; dis[(*it).to][nd%m])&#123; dis[(*it).to][nd%m] = nd; Q.push(nod((*it).to,nd)); &#125; &#125; &#125;｝int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; for(int i = 1; i &lt;= 4; ++i) E[i].clear(); cin &gt;&gt; k &gt;&gt; d12 &gt;&gt; d23 &gt;&gt; d34 &gt;&gt; d41; E[1].push_back(edge(1,2,d12));E[2].push_back(edge(2,1,d12)); E[2].push_back(edge(2,3,d23));E[3].push_back(edge(3,2,d23)); E[3].push_back(edge(3,4,d34));E[4].push_back(edge(4,3,d34)); E[4].push_back(edge(4,1,d41));E[1].push_back(edge(1,4,d41)); m = 2 * min(d12,d23); dij(); ll ans = llinf; for(int i = 0; i &lt; m; i++)&#123; if(dis[2][i] &gt;= k) ans = min(ans,dis[2][i]); else&#123; ll delt = k - dis[2][i]; dis[2][i] += (delt/m+(delt%m?1:0))*m; ans=min(ans,dis[2][i]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 至此，dijkstra算法的介绍告一段落。 SPFA(待补)同样为单源最短路算法，相较于dijkstra的优势是可以判断负环，劣势是比较慢。是优化版的Bellman-Ford算法。模版及例题待补 Bellman-Ford他死了。 多源最短路给定若干点以及点之间的距离(边)，要求求出任意两点间的最短距离。 Floyed算法又名Warshall算法。暴力遍历O($n^3$)次点，对于任意两点i,j，如果以k为桥梁能使i ~ j的距离变短，那么更新i ~ j的距离。由于算法特性，只能用邻接矩阵来存图。算法主体代码： 1234for(int k = 1; k &lt;= n; k++)for(int i = 1; i &lt;= n; i++)for(int j = 1; j &lt;= n; j++)w[i][j] = min(w[i][j], w[i][k] + w[k][j]); 给出一道例题：poj2139AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;typedef long long ll;const int inf = 0x3f3f3f3f;using namespace std;int w[303][303], tmp[303];int main()&#123; int n, m, t; scanf(\"%d %d\", &amp;n, &amp;m); memset(w, inf, sizeof(w)); for(int i = 1; i &lt;= n; i++) w[i][i] = 0; while(m--) &#123; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; tmp[i]; &#125; for(int i = 0; i &lt; t; i++) for(int j = 0; j &lt; i; j++) w[tmp[i]][tmp[j]] = w[tmp[j]][tmp[i]] = 1; &#125; for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); double ans = inf; for(int i = 1; i &lt;= n; i++) &#123; int sum = 0; for(int j = 1; j &lt;= n; j++) sum += w[i][j]; ans = min(ans, sum * 100 * 1.0/ (n - 1)); &#125; printf(\"%d\\n\", (int)ans); return 0;&#125; 非常简单的一个算法，但是他的空间复杂度和时间复杂度都过高，并不常用。 后记好吧，从篇幅上可以看出，最短路算法中最常用，最强大的算法就是dijkstra了，他的变形也有很多，需要好好掌握哦！本文中一些STL会在将来的文章里补上用法。emmm可能会吧","tags":[{"name":"贪心","slug":"贪心","permalink":"https://lotusir.github.io/tags/贪心/"},{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"最短路问题","slug":"最短路问题","permalink":"https://lotusir.github.io/tags/最短路问题/"}]},{"title":"Trie","date":"2019-07-01T13:24:40.000Z","path":"2019/07/01/Trie/","text":"TrieTrie，也叫做字典树，是一种树形结构，可以高效的存储字符串和查询字符串。 Trie比较简单，这里只做简单的介绍，并给出例题和模版。例题：hdu1251题意简述：给定一系列字符串，再给出多个前缀，输出这些前缀在多少个字符串中出现过。 Trie的组成这种树形结构只有一个根节点，根节点没有意义（虚节点）。网上很多文章中将每一个节点视为一个字符，但事实并非如此，在Trie中，每一条边代表了一个字符，而从根节点走到某一节点路径上所有字符组成的字符串，则为该节点所代表的字符串。为了方便讲解，这里直接给出Trie节点的定义： 123456789101112struct trie&#123; trie *nxt[26]; //子节点的指针数组，此处26为字符集的大小，可以根据需求修改 int cnt; //此题用于统计前缀，根据需求修改 //初始化 trie() &#123; cnt = 1; //初始化所有nxt为NULL memset(nxt,NULL,sizeof(nxt)); &#125;&#125;; 我们可以认为，从一个节点p到节点p-&gt;nxt[id]的边所代表的字符即为i所映射的字符。以a ~ z映射到0 ~ 25为例，root-&gt;nxt[0]-&gt;nxt[1]-&gt;nxt[2]节点所代表的的字符串就是abc。 Trie的构建与线段树不同，Trie并不是输入完所有字符串后统一构建的(当然你想这么做也是可以的，但是会MLE),Trie的构建通常是输入一个字符串就插入一个字符串，插入的过程很简单，如果nxt[id]已经存在就沿着走，如果不存在就新建一个。以下为代码实现： 12345678910111213141516171819202122void Insert(char *s)&#123; trie *p = root; i = 0; //遍历字符串 while(s[i])&#123; id = s[i] - 'a'; //如果存在，就沿着走，并操作路径上的统计量（此处用于统计前缀） if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; //如果不存在，就新建，当然也要走过去 else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125; Trie的查询字典树的查询视题意而定，在本次例题中，为统计前缀出现的次数。根据字符串沿着树遍历即可，若遇到nxt[id]==NULL的情况，说明没找到，直接返回0。以下为代码实现 12345678910111213141516int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; //找得到就沿着走 if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; //找不到直接返回0 else return 0; i++; &#125; //若找到了，返回最终节点的cnt值 return p -&gt; cnt;&#125; Trie的删除递归删除即可 123456void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125; 例题+模版回到例题的解答，解题过程非常简单毕竟是模版题1.根据给出的字符串建立Trie2.根据前缀在Trie上遍历 AC代码（模版）：本题用C++提交的，用G++提交有惊喜哦本题G++提交会MLE，请用C++提交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const int maxn = 11;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; int cnt; trie() &#123; cnt = 1; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int i,id;char S[maxn],s1[maxn];void Insert(char *s)&#123; trie *p = root; i = 0; while(s[i])&#123; id = s[i] - 'a'; if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125;int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; else return 0; i++; &#125; return p -&gt; cnt;&#125;void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125;int main()&#123; root = new trie; while(scanf(\"%s\",S))&#123; Insert(S); cin.get(); if(cin.peek() == '\\n') break; &#125; while(scanf(\"%s\",s1) != EOF)&#123; printf(\"%d\\n\",query(s1)); &#125; return 0;&#125;","tags":[{"name":"Trie","slug":"Trie","permalink":"https://lotusir.github.io/tags/Trie/"},{"name":"字符串","slug":"字符串","permalink":"https://lotusir.github.io/tags/字符串/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lotusir.github.io/tags/数据结构/"}]},{"title":"AC自动机","date":"2019-07-01T11:10:50.000Z","path":"2019/07/01/ACautoman/","text":"AC自动机AC自动机，用于多模字符串匹配，类似KMP+Trie。 一种最常见的题目如下（裸题模版）题意简述：首先输入多个单词（模式串），接着输入一串目标字符串，输出有多少个模式串在目标字符串中出现过。解题步骤：1.根据给出的模式串构造一个Trie树。2.在Trie树上构造fail指针（构造Trie图）。3.将目标字符串在Trie图上进行匹配。 Fail指针Fail指针的构造过程：1.用BFS的顺序逐层向下构造Fail指针。2.当一个节点的父亲指针为Root时，将Fail指针指向Root。3.当要获取一个节点（父节点不为Root）的Fail指针时，从其父亲指针的Fail指针开始查找与自己同名的子节点，若找到，则这个节点的Fail指针指向该与自己同名的子节点；若找不到，则沿着Fail指针继续寻找直到找到或直到指向Root时仍找不到。若指向根节点时仍然找不到，及当前节点没有Fail指针，将Fail指针指向Root。具体代码如下： 12345678910111213141516171819202122232425262728293031323334void getFail()&#123; queue&lt;trie*&gt; q; //用于BFS q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; //父节点为root的节点fail指针指向root if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; //从父节点的fail指针开始查找 temp = p -&gt; fail; //当temp为NULL时即没有找到同名的子节点 while(temp)&#123; //找到了与自己同名的子节点，则让当前节点的fail指向该子节点，同时结束循环 if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; //沿着fail指针继续查找 temp = temp -&gt; fail; &#125; //temp为NULL，即没有找到同名的子节点，将fail指针指向root if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; //bfs q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125; Fail指针具有的特点：1.从任意节点沿着fail指针遍历，总能回到root节点。2.一个节点的fail指针指向的节点所代表的字符串，为当前节点字符串的某一后缀，因此当匹配时匹配到当前节点时，当前节点fail指针所指向的字符串也一定出现过了，所以在匹配过程中每匹配一个字符，要沿着fail指针跳回root。 查询过程查询步骤：1.如果当前字符匹配，则沿着nxt[id]向下走；如果当前字符不匹配，则沿着fail指针查找nxt[id]直到找到或指向root。2.每匹配完一个字符，沿着fail指针跳回root同时统计路径上出现的单词数。3.将匹配过的模式串打上标记避免重复统计。具体代码如下： 12345678910111213141516171819202122232425int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; //遍历字符串s while(s[i])&#123; //26个小写字母映射到0~25 int id = s[i] - 'a'; //若没有找到nxt[id]且当前指针没有指向root（root的fail指针为NULL），则沿着fail指针遍历直到找到或指向root while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; //若p==NULL，说明最终都没有找到，让p指向root if(p == NULL) p = root; //从p开始跳fail指针统计路径上的单词数 temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; //统计后打上标记（清零单词数量） temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125; 例题+模版hdu2222题意简述：首先输入多个单词（模式串），接着输入一个目标字符串，输出有多少个模式串在目标字符串中出现过。以下为AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;typedef unsigned long long ull;const int P = 1e9+7;const int maxn = 5e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; trie *fail; int cnt; //计算前缀时可用，本题无用 int flag; //记录当前节点结束的字符串个数 trie()&#123; cnt = 1; flag = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int T,N,Q;char S[maxn],s1[maxn],s2[maxn];void Insert(char *s)&#123; trie *p = root; int len = strlen(s); for(int i = 0; i &lt; len; i++)&#123; int id = s[i] - 'a'; if(p-&gt;nxt[id] != NULL)&#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else&#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; p -&gt; flag++;&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; temp = p -&gt; fail; while(temp)&#123; if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; while(s[i])&#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125;//递归释放Trievoid Free(trie *p)&#123; for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; root = new trie; scanf(\"%d\",&amp;N); while(N--) &#123; scanf(\"%s\",S); Insert(S); &#125; getFail(); scanf(\"%s\",s1); printf(\"%d\\n\",query(s1)); Free(root); &#125;&#125;","tags":[{"name":"字符串","slug":"字符串","permalink":"https://lotusir.github.io/tags/字符串/"},{"name":"kmp","slug":"kmp","permalink":"https://lotusir.github.io/tags/kmp/"},{"name":"trie","slug":"trie","permalink":"https://lotusir.github.io/tags/trie/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://lotusir.github.io/tags/AC自动机/"}]}]