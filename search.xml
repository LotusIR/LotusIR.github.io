<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU6096-String（AC自动机）]]></title>
    <url>%2F2019%2F07%2F04%2FHDU6096%2F</url>
    <content type="text"><![CDATA[题目地址：HDU6096Problem DescriptionBob has a dictionary with N words in it.Now there is a list of words in which the middle part of the word has continuous letters disappeared. The middle part does not include the first and last character.We only know the prefix and suffix of each word, and the number of characters missing is uncertain, it could be 0. But the prefix and suffix of each word can not overlap.For each word in the list, Bob wants to determine which word is in the dictionary by prefix and suffix.There are probably many answers. You just have to figure out how many words may be the answer. InputThe first line of the input gives the number of test cases T; T test cases follow.Each test case contains two integer N and Q, The number of words in the dictionary, and the number of words in the list.Next N line, each line has a string Wi, represents the ith word in the dictionary (0&lt;|Wi|≤100000)Next Q line, each line has two string Pi , Si, represents the prefix and suffix of the ith word in the list (0&lt;|Pi|,|Si|≤100000,0&lt;|Pi|+|Si|≤100000)All of the above characters are lowercase letters.The dictionary does not contain the same words. LimitsT≤50&lt;N,Q≤100000∑Si+Pi≤500000∑Wi≤500000 OutputFor each test case, output Q lines, an integer per line, represents the answer to each word in the list. Sample Input14 4abacdeacdefacdefa acd efac ace f Sample Output2110 题意：给若干个字符串，进行若干次询问，每次询问给出一个前缀和后缀，问同时有这个前缀和后缀的字符串有几个，前缀与后缀不能重叠。解题：一道构造很巧妙的AC自动机题，首先存下给出的字符串，接着将给出的前缀(s1)和后缀(s2)以s2 + ‘{‘ + s1的形式插入字典树，构造AC自动机Fail指针，然后将每个字符串S转换成S + ‘{‘ + S的形式在AC自动机上跑，每经过一个结束节点就在这个节点的计数器上加一，不过要注意由于前缀和后缀不能重叠，因此s2+s1的长度不能超过S，最后按照询问的顺序输出结束节点的计数器即可。之所以用’{‘是因为它等于’a’+26容易建树，当然也可以用别的字符。以cd ef的查询为例，他被构造成了”ef{cd”插入了字典树，那么当用cdef{cdef跑AC自动机时就会找到这个子串。如果不用’{‘分割，那么ab cd就会匹配到aabcde，显然是不对的。最后是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;const int maxn = 1e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[27]; trie *fail; int len; int cnt; trie() &#123; len = 0; cnt = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root,*tr[maxn];int T,N,Q,tot;string S[maxn],s1,s2;void Insert(string s)&#123; trie *p = root; for(int i = 0; i &lt; s.length(); i++) &#123; int id = s[i]-'a'; if(p-&gt;nxt[id] != NULL) &#123; p = p-&gt;nxt[id]; &#125; else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; tr[tot++] = p; p -&gt; len = s.length();&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty()) &#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 27; ++i) &#123; if(p -&gt; nxt[i]) &#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else &#123; temp = p -&gt; fail; while(temp) &#123; if(temp -&gt; nxt[i]) &#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;void query(string s)&#123; trie *p = root; trie *temp; for(int i = 0; i &lt; s.length(); ++i)&#123; int id = s[i]-'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root) &#123; if(temp-&gt;len &lt;= (s.length()-1)/2+1) temp-&gt;cnt++; temp = temp -&gt; fail; &#125; &#125;&#125;void Free(trie *p)&#123; for(int i = 0; i &lt; 27; ++i) &#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; tot = 0; root = new trie; cin &gt;&gt; N &gt;&gt; Q; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; S[i]; S[i] = S[i] + '&#123;' + S[i]; &#125; while(Q--)&#123; cin &gt;&gt; s1 &gt;&gt; s2; Insert(s2+'&#123;'+s1); &#125; getFail(); for(int i = 0;i &lt; N; ++i) query(S[i]); for(int i = 0;i &lt; tot;i++) cout &lt;&lt; tr[i]-&gt;cnt&lt;&lt; endl; Free(root); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM解题报告</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F07%2F03%2FUnionFind%2F</url>
    <content type="text"><![CDATA[并查集并查集是一种数据结构，用于快速合并多个集合以及查询两个节点是否在同一个集合中。 引言思考一个简单的问题：有若干个点，每一次将其中两点连起来，若干次操作后，询问任意两点是否被联通。这样的问题要怎么解决呢？废话，当然就是要依靠本文下面将介绍的并查集的算法啦！ 思考问题对于这样的问题，显然我们可以直接将两点相连，但如果这么做，询问时就会遇到麻烦。DFS?BFS?当点的数目非常多时，这么做的复杂度似乎太高了。 并查集的作用顾名思义，并查集主要有两个作用，“并”和“查”。“并”，就是将两个集合合并到一起；“查”就是是查询两点是否在同一集合中。它的主要作用就是用来解决形如引言中那样的问题。并查集采用的是一种类树形结构，那么为什么要采用类树形结构呢？因为无论是合并还是查询，树形结构都很方便，也很快。大家知道，一棵k叉树的查询复杂度是O(logk(n))，除非k等于一，否则查询的速度是非常可观的。同时，要合并两棵树也非常容易——只要将两棵树的根直接相连就可以了。 并查集的结构体实现并查集既可以用结构体实现，也可以用数组实现，这里首先给出结构体的实现和讲解，文末给出数组实现，留给读者自己思抄考写。 节点的定义首先是并查集节点的定义，之所以说并查集是一种类树形结构，是因为它与树形结构有所不同，它的节点指针方向是与树相反的。树形结构的指针方向，由父节点指向子节点，而并查集节点的指针方向则由子节点指向父节点。（可以把并查集的这种数据结构看做一棵倒着的树）。所以，并查集的结构体非常简单，只需要一个指向父节点的指针以及原始数据即可。 123456struct node&#123; //数据 int id; //父节点 node *father = NULL;&#125; 路径压缩在开始具体代码的实现前，我们来理一理逻辑。要怎么合并两棵树？连接两棵树的根节点即可。要怎么连接两棵树的根节点呢？很简单，让某一个根节点的父亲指针指向另一个就行了，不过在这之前我们必须要先找到他们的根节点。因此下面会首先给出寻找根节点的代码实现，那么路径压缩又是什么呢？我们知道，一棵树的深度越浅，我们寻找根节点的效率也就越高，最优的情况下是怎样的呢？所有的节点都紧紧围绕着根节点就像全中国人民紧密团结在习主席周围。要单独进行这样的优化比较浪费时间，因此我们可以在寻根的过程中一并递归处理，当然这样并不能保证所有节点直接连接根节点，但已经足够紧密了。 并查集的寻根知道路径压缩以后，我们可以开始寻找根节点了。寻根过程很简单，一路沿着某一节点搜索父节点指针，直到没有父节点或者父节点是其自身（这两种情况是等价的，与代码实现有关）就可以了。那么路径压缩呢？只要将寻根过程碰到的所有节点的父指针直接指向根节点就可以了，这个操作可以用递归的方式简单实现。代码如下： 1234node* FindRoot(node *a)&#123; if(a-&gt;father == NULL) return a; else return a-&gt;father = FindRoot(a-&gt;father);&#125; 并查集的合并合并过程在之前就已经说过了，对于两个节点，如果根节点不同，将一个的根节点的父亲指针指向另一个根节点，如果相同，那么不需要进行合并操作。因为已经有了寻根的函数，合并的实现就变得非常简单，代码如下： 12345void Union(node *from,node *to)&#123; node *f1 = FindRoot(from),*f2 = FindRoot(to); if(f1 == f2) return; f2-&gt;father=f1;&#125; 例题及数组实现解释完并查集的结构体实现，那么又到了喜闻乐见的模版和例题环节了，模版中用数组实现了并查集。例题：HDU1232题意：给出若干个点和若干条边，询问要将整张图联通起来，至少还需要几条边。解题思路：这是一道模版题，时间很充裕，用并查集可以简单得出结果。步骤如下1.对于给出的每一条边，对边的两个端点进行“并”的操作。2.完成第1步后，整张图被分为了多个互相之间不连通的集合，要让整张图连通，需要的边数就是集合数减一。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int maxn = 1500;using namespace std;int N,M,father[maxn],a,b,vis[maxn],cnt;int Find(int a)&#123; if(father[a]==a) return a; return father[a]=Find(father[a]);&#125;void Union(int a,int b)&#123; int f1=Find(a),f2=Find(b); father[f2] = f1;&#125;void init()&#123; for(int i = 1; i &lt;= N; ++i) father[i]=i; memset(vis,0,sizeof(vis)); cnt=0;&#125;int main()&#123; //用于加速输入输出，忽视就行了 ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; N)&#123; if(N==0)break; cin &gt;&gt; M; init(); while(M--)&#123; cin &gt;&gt; a &gt;&gt; b; Union(a,b); &#125; for(int i = 1; i &lt;= N; ++i)&#123; int tmp = Find(i); if(!vis[tmp])&#123; cnt++; vis[tmp]=1; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125; 后记并查集的介绍到此结束，这是一种比较简单的数据结构，在Kruscal算法中会用到并查集的算法。]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶]]></title>
    <url>%2F2019%2F07%2F03%2Ftop%2F</url>
    <content type="text"><![CDATA[大佬队友的博客 SHU-SSYZE 本博客会不定时更新一些ACM的算法和自闭日记，也有可能会更新些别的吧，上面是大佬队友的博客哦~]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树基础]]></title>
    <url>%2F2019%2F07%2F02%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[线段树线段树是一种树形数据结构，用于快速统计和修改区间上的统计量。 线段树能做什么？线段树是一种完全二叉树，建树的时间复杂度为O(nlogn)，查询以及修改的复杂度都是O(logn)，可以高效的查询和修改区间统计量。 线段树的组成线段树的每一个节点上隐式地存储着这个节点所“掌管”的区间，显式地存储着节点所“掌管”区间上的某一或某些统计量。需要注意的是，这些统计量必须满足区间加法（如区间最大值是子区间最大值中的最大值，区间和为子区间和的和等），众数、最长上升子序列等不符合区间加法。如果要用结构体实现，它的节点定义将会是这样的: 1234struct node&#123; node *ls,*rs; //ls为节点左子节点的指针，rs为右子节点的指针 int sum,mx; //统计量，常用的是区间和以及区间最值&#125; 显然，如果给定一个数组a1,a2…an,以[1,n]为范围建立线段树，那么根节点所掌管的区间（这里的区间是指数组下标，而不是数字范围）就是[1,n]，而其左子节点掌管的区间是[1,n/2],右子节点掌管的区间是[n/2+1,n]。以此类推可以知道每一个节点所掌管的区间，这也就是为什么我说每一个节点上隐式地存储着这个节点所“掌管”的区间的原因。以区间[1,10]为例，一棵建好的线段树每一个节点所掌管的区间情况如下图所示： 线段树的结构体实现线段树可以用结构体和指针来实现，也可以用数组来实现，结构体的实现较为容易理解，因此本文将先用结构体来实现线段树，在本文最后会给出数组的实现方法。 区间加法用一个节点两个子节点的统计量来更新自己的统计量。具体见代码： 1234void pushup(node *rt)&#123; rt-&gt;mx = max(rt-&gt;ls-&gt;mx,rt-&gt;rs-&gt;mx); rt-&gt;sum = rt-&gt;ls-&gt;sum + rt-&gt;rs-&gt;sum;&#125; 这个函数在构造和修改值的过程中都会用到。 线段树的构造线段树的构造是一个递归建树的过程，这里直接贴上代码，边读代码边解释。 1234567891011121314//首先解释一下这5个参数//[L,R]是建立线段树所依赖的数组范围，在递归过程中不变//rt是当前递归到的指针，[l,r]是当前指针所掌管的区间，这3个变量将作为状态在递归过程中传递void build(int L,int R,int l,int r,node *rt)&#123; //如果当前指针掌管的范围只有一个元素，直接赋值并返回 if(l == r)&#123;rt -&gt; sum = a[l];rt -&gt; mx = a[r];return;&#125; //找到区间的中点 int m = (l+r) &lt;&lt; 1; //递归构造左子树和右子树 build(L,R,l,m,rt-&gt;ls); build(L,R,m+1,r,rt-&gt;rs); pushup(rt); return;&#125; 在主函数中呼叫构造函数时的初始状态通常为build(1,N,1,N,root)。 线段树的修改线段树的修改步骤大致分为两步：1.从根节点开始查找我要修改的值所在的叶节点。（没有子节点的节点称为叶节点）2.修改叶节点，沿着查找路径递归更新与该叶节点相连的所有节点。代码如下： 123456789101112131415//再来解释一下这5个参数//P是我要修改的值所在的位置，V是我要将其修改为的值//l,r,rt的含义与build中相同void update(int P,int V,int l,int r,node *rt)&#123; //找到了目标叶节点，更新叶节点的值，显然此时l=r=P if(l==r)&#123;rt-&gt;sum=V;rt-&gt;mx=V;return&#125;; //同样找出区间中点 int m = (l+r) &lt;&lt; 1; //如果目标叶节点在区间左半，向左子树找，否则向右子树找 if(P&lt;=m) update(P,V,l,m,rt-&gt;ls); else update(P,V,m+1,r,rt-&gt;rs); //递归更新与被修改的叶节点相连的所有节点 pushup(rt); return;&#125; 在主函数中呼叫时的方式是update(P,V,1,N,root)其中P、V的含义见代码注释。 线段树的查询到了最重要的查询步骤了，查询最值与查询区间和的方法大同小异。从根节点开始向下搜索，如果要查询的区间完全包含（可以相等）某一节点所掌管的区间，将这个区间的统计量加入到最终结果中；如果要查询的区间不能完全包含某一节点所掌管的区间，继续拆分这个区间直到要查询的区间能够完全包含它。具体见代码实现： 1234567891011121314151617//查询最值//[L,R]是要查询的区间//l,r,rt的含义与之前相同int querymx(int L,int R,int l,int r,node *rt)&#123; //如果查询区间完全包含当前节点所掌管的区间，返回最大值 if(L &lt;= l &amp;&amp; R &gt;= r) return rt-&gt;mx; //初始化最大值为负无穷 int res = -inf; //求出线段中点 int m = (l+r) &lt;&lt; 1; //L&lt;=m说明要查询的区间可以继续往左子树拆分 if(L &lt;= m) res = max(res,querymx(L,R,l,m,rt-&gt;ls)); //R&gt;=m+1说明要查询的区间可以继续往右子树拆分 if(R &gt;= m+1) res = max(res,querymx(L,R,m+1,r,rt-&gt;rs)); //最终得出结果 return res;&#125; 注意在上述代码中L&lt;=m和R&gt;=m+1并不是if和else的关系，一个线段可以同时既可以往左拆分也可以往右拆分（例如要查询的区间是[4,6]而当前节点掌管的区间是[1,10]），但2种情况至少成立1种（否则L就会大于R），因此-inf并不会被计算到最终结果中去。查询区间和的方法类似，只要进行简单修改就可以了： 12345678int querysum(int L,int R,int l,int r,node *rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return rt-&gt;sum; int res = 0; int m = (l+r) &lt;&lt; 1; if(L &lt;= m) res += querysum(L,R,l,m,rt-&gt;ls); if(R &gt;= m+1) res += querysum(L,R,m+1,r,rt-&gt;rs); return res;&#125; 其实只是改变了统计量的“区间加法”部分的代码，注意此时res只能被初始化为0。 线段树的数组实现说明完线段树的结构体实现，接下来就是线段树的数组实现了，大部分代码与结构体实现类似，只是把节点抽象到了统计量数组的下标上，此时对于任意一个节点$rt$，它的左子节点是$rt * 2$,它的右子节点是$rt * 2+1$,个人习惯用rt&lt;&lt;1表示$rt * 2$,用rt&lt;&lt;1|1表示$rt * 2+1$。数组实现线段树的方法代码较为简洁，但理解起来稍有些抽象。这里是一道例题：HDU1754以下给出完整的AC代码（数组实现线段树的模版）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200000 + 5;const int inf = 0x3f3f3f3f;int N,M,mark[maxn],Max[maxn&lt;&lt;2]; //数组要开到区间长度的4倍确保空间够用//更新当前节点void pushup(int rt)&#123; Max[rt] = max(Max[rt&lt;&lt;1],Max[rt&lt;&lt;1|1]);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号void build(int l,int r,int rt)&#123; if(l == r)&#123;Max[rt] = mark[l];return;&#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 [L,R]查询的区间int query(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return Max[rt]; int m = (l+r) &gt;&gt; 1; int res = 0; if(L &lt;= m) res = max(res,query(L,R,l,m,rt&lt;&lt;1)); if(R &gt; m) res = max(res,query(L,R,m+1,r,rt&lt;&lt;1|1)); return res;&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 将L的值改为Vvoid update(int L,int V,int l,int r,int rt)&#123; if(l==r)&#123;Max[rt]=V;return;&#125;; int m = (l+r) &gt;&gt; 1; if(L &lt;= m) update(L,V,l,m,rt&lt;&lt;1); else update(L,V,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M) != EOF)&#123; for(int i = 1; i &lt;= N; ++i) scanf("%d",&amp;mark[i]); build(1,N,1); char c; int a,b; while(M--)&#123; scanf(" %c%d%d",&amp;c,&amp;a,&amp;b); if(c=='Q') printf("%d\n",query(a,b,1,N,1)); else update(a,b,1,N,1); &#125; &#125; return 0;&#125; 读者可以结合注释与前文结构体实现的代码进行对照理解。 后记又一个数据结构写完了，当然以后还会更新线段树的加强版：主席树、红黑树等，敬请期待咯~另外本文参考了这篇文章同时也在继续学习这篇文章。]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数相关]]></title>
    <url>%2F2019%2F07%2F02%2Fprime%2F</url>
    <content type="text"><![CDATA[素数素数，就是因数只有1和自己的数，本文将介绍一些素数相关的内容。 素数筛一种快速找出一定范围内所有素数的方法。 埃拉托斯特尼筛法简称埃氏筛或埃筛，是一种十分好写也十分容易理解的素数筛法。原理十分简单，如果一个数是素数，那么他的任意倍数一定不是素数。因此我们首先假设所有数都是素数，接着从2开始找，2是素数，那么把它的所有倍数标记为非素数，从小到大开始筛，这样当我们找到一个数还没有被标记为非素数的话，它一定是一个素数，再次标记它的所有倍数为非素数，依此循环。下面给出代码： 1234567891011121314151617#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 4e3;//只筛到maxn以内的质数using namespace std;int not_prime[maxn],prime[maxn];void getprime()&#123; int cnt = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i])&#123; prime[cnt++] = i; for(int j = i + i; j &lt;= maxn; j+=i) not_prime[j] = 1; &#125; &#125;&#125; 欧拉筛法又名快速素数筛或欧筛，一听名字就知道它很快。那么为什么欧拉筛法比埃氏筛快呢，或者说，埃氏筛法哪里慢了？观察埃氏筛法，我们发现，同一个合数，它有可能被多个素数筛到，比如6被2筛到之后又会被3筛到，这就造成了多余的运算。而欧拉筛避免了这一点，在欧拉筛中每一个合数都只会被筛到一次，实现了线性复杂度O(n)。 过程简述欧筛的过程简述如下：1.与埃筛一样，将所有数假设为素数。2.从2开始遍历，如果遇到一个素数，那么将这个素数加入素数表。3.无论遇到的是不是素数，都遍历素数表（为了方便表述，设这个数为N，当前遍历到的素数为P），将$N*P$标记为非素数，如果此时N能够被P整除，那么结束素数表的遍历，否则继续遍历素数表。 过程模拟为了方便理解，这里给出10以内的素数的遍历过程。（已经理解的跳过分割线内的内容） 初始状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 0 0 0 0 0 0 0 素数表为空遍历到2时，2是素数，将2加入素数表，遍历素数表，$22=4$标记为非素数，因为2能整除2，结束素数表的遍历。此时状态：*not_prime数组**(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 0 0 0 0 0 素数表 2 接着遍历3，3是素数，将3加入素数表，遍历素数表会将6和9标记为非素数。此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 0 1 0 素数表 2 3 遍历4，4不是素数，不加入素数表，遍历素数表，会将8标记为素数（2能整除4，因此只遍历到2就结束素数表的遍历）此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 1 1 0 素数表 2 3 遍历5，5是素数，将5加入素数表，遍历素数表会把10，15，25标记为非素数。此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 1 1 1 素数表 2 3 5 实际上至此10以内的所有素数已经全部被筛出了，接着遍历6会将12标记为非素数，而遍历7会把14、21、35、49标记为非素数……在这个过程中，每一个合数都只会被筛到一次，证明略。 具体代码给出代码实现： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e6;using namespace std;int not_prime[maxn],prime[maxn];void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125; 相较于埃氏筛，欧拉筛法更快，且没有其他缺点，因此实际上只要记住欧拉筛就可以了埃氏筛比较好记就是了 分解素因数将一个大合数N分解成素因数的乘积，方法如下：1.用欧拉筛或埃氏筛得到素数表。2.从素数表中最小的素数P开始，如果N能够被P整除，那么将N /= P，并将P作为素因数的指数加一，重复这个步骤直到N不能被P整除。3.用下一个较大的素数重复第2步，直到取出大于$sqrt(N)$的第一个素数。4.如果N已经被除到了1，那么素因数分解完毕，如果N还没有被除到1，那么N最终的值是它自己的最后一个素因数。 用途较少，这里给出一道可用这种方法解答的例题：SHUOJ2只能用校内网连上，连不上就算了。。题意简述：给定正整数A,B（1&lt;=A,B&lt;=1000）,求$GCD(A,B^B)$。解题思路：由于B较大，显然不能直接求出$B^B$再求GCD，因此对A和B进行素因数分解，再将B的每一个素因数的指数乘以B，就能得出$B^B$的素因数，A和B的公共素因数的乘积就是所求的答案。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e3;using namespace std;int not_prime[maxn],prime[maxn],cnt[2][35],A,B;void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; j&lt;tot &amp;&amp; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;//快速幂int qpow(int x,int y)&#123; int res = 1; while(y)&#123; if(y&amp;1) res = res * x; y &gt;&gt;= 1; x = x * x; &#125; return res;&#125;int main()&#123; getprime(); while(cin &gt;&gt; A &gt;&gt; B)&#123; memset(cnt,0,sizeof(cnt)); int t = B; for(int i = 0; i &lt;= 30; i++)&#123; while(A % prime[i] == 0)&#123;cnt[0][i]++;A /= prime[i];&#125; while(B % prime[i] == 0)&#123;cnt[1][i]++;B /= prime[i];&#125; cnt[1][i] *= t; &#125; int ans = 1; for(int i = 0; i &lt;= 30; i++)&#123; ans *= qpow(prime[i],min(cnt[0][i],cnt[1][i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 本题还有另一种做法,之后可能会补上。此外，有一件很奇怪的事就是当maxn取某些值的时候，prime[0]会莫名其妙变成1，暂时没有发现原因。。 后记素数相关的算法和思想还是比较重要的，HDU的多校赛经常出现GCD等相关问题。今天的训练赛打的真是自闭]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>素数筛</tag>
        <tag>分解因数</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM暑期训练赛（HDU07）]]></title>
    <url>%2F2019%2F07%2F02%2FHDU07%2F</url>
    <content type="text"><![CDATA[2019/07/02 阴有雨又是自闭的一天2019/07/03 晴？阴？更新了B、C、H的题解 比赛地址：HDU07 HDU07A All Kill（待补） B Build a Tree题意：给出一棵有N个节点的完全K叉树，求这棵树所有子树大小异或后的答案。解题：待补，考虑将子树分为完整的K叉树和不完整的K叉树，不完整的k叉树至多只有一棵，单独处理这棵树，从树的最底层向上递归求解。 C Color the chessboard题意：给出一张矩形图，图上每一个单位矩形初始状态下被涂为白色或红色或蓝色，现在要将这张图上的每一个白色的单位矩形染上色，要求所有具有偶数行数和偶数列数的矩形中所含有的蓝色矩形和红色矩形数量相等。解题：待补，显然只要所有的2*2的矩形都满足条件，那么就能满足条件，DFS or DP？ D Destroy the cube(待补) E Euler theorem题意：给出若干个整数，对于每一个整数，要求输出这个整数余除以任意一个数能得到的余数的个数。（如，对于3，3%3=0,3%4=3,3%2=1,任何数都不能让3余2，因此有3个余数）。解题：签到题打表就能得到答案。显然，对于一个数N，任何数不可能让它余超过$(N-1)/2$，而任意不超过N/2的余数都是有可能得到的，因此最终的答案就是$N/2+2$(1~N/2以及0和N)。简单证明：要让$N$余一个数$m$，只要让他余除$N-m$就可以了，但当$m&gt;(N-1)/2$时$2(N-m)&lt;N+1$,即$2(N-m)&lt;=N$,这时$N$余除$(N-m)$的值就变成了$N$余除$2(N-m)$的值，显然这是一个小于$(N-1)/2$的值。 F Free from square题意：给出两个整数n,K（小于500），要求从1 ~ K中挑出n个整数，这些整数的乘积不能被任何完全平方数（除了1）整除，输出可行的方案数。解题：待补，显然不能选相同的数字，且选了一个数以后不能再选任何它的倍数。然后不会了 G Give out candies（待补） H Hard challenge题意：在二维坐标平面上给出若干个点的坐标和权值，保证任意两点所连成的直线不经过原点，任意两点间的边的权值等于这两点权值的乘积，现在要求过原点画一条直线，这条直线所穿过的边的权值之和最大，输出最大的权值。解题：代码待补1.首先，任何一条过原点的直线所穿过的边的权值之和，等于直线一边所有点的权值之和乘以直线另一边所有点的权值之和。2.根据原点到每一个点连线的斜率，可以将所画直线的斜率分成若干个区间，枚举这些区间就能得出答案。3.为了得到区间，首先需要将点按照斜率的不同进行排序（极序排序），接着按照第0个点到第1个点间，第1个点到第2个点间……的顺序进行枚举。4.可以在0 ~ 360°的区间内维护一个前缀和快速得出某一直线两边的点的权值之和。 I Inverse of sum（待补） J Just do it题意：给出一个数列a0a1a2……an，要求进行一种运算m次，这种运算就是将每一个ai变成bi，切bi的值等于原数列ai从a0异或到ai的结果。解题：待补，找规律？我找了个规律然后T了(┬＿┬) K Kolakoski题意：有一种特殊的数列，它的第一项是1，这个数列形如：1，2，2，1，1，2，1，2，2……，将这个数列相同的项合并会变成1，22，11，2，1，22……，计算每一项的位数作为新数列这一项的值会变成1，2，2，1，1，2……，我们发现这个数列变回了最初的数列，现在要求输出这个数列的第n项（n&lt;1e7）。解题：n的数值较小，直接用vector暴力模拟即可。简述模拟过程：1.首先初始化数列的前3项为1，2，22.接着将指针指向第3项（2）。3.沿着指针，如果发现了一个2，那么需要在队尾添加两个相同的数，但这个数要与前一个数不同，因此如果此时队尾元素是1那么push_back两个2，如果队尾元素是2那么push_back两个1；如果发现了一个1，那么push_back一个与队尾元素不同的数即可。贴上AC的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; s;int main()&#123; int t,temp; //模拟过程 s.push_back(1); s.push_back(2); s.push_back(2); for(int i=2;i&lt;1e7+5;i++) &#123; temp = s.size() - 1; if(s[i] == 1) &#123; if(s[temp] == 1) &#123; s.push_back(2); &#125; else &#123; s.push_back(1); &#125; &#125; else &#123; if(s[temp] == 2) &#123; s.push_back(1); s.push_back(1); &#125; else &#123; s.push_back(2); s.push_back(2); &#125; &#125; &#125; //模拟结束 cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; cout&lt;&lt;s[n-1]&lt;&lt;endl; &#125;&#125; L Loop next（待补） M Mystery（待补） 看看明天能补几道吧。。(┬＿┬) 补题日记7/3H Hard challenge解题：大致解法与昨天写的差不多，不过实际写代码的时候有一些问题，因此做了一些改变，改变后的解题方法如下：1.将所有点按照斜率k从大到小的顺序排序。2.初始状态下让所画的直线竖置，这样将所有点分为直线左边的点与直线右边的点两组（特别注意在y轴上的点分在直线右边，此时可以认为直线并不完全竖置），输入时统计直线左边的点权和lsum和直线右边的点权和rsum。3.维护lsum和rsum。按k从大到小的顺序遍历每一个点，每一次改变直线将这个点的分组改变（由于已经按k排序，每次移动直线只会有一个点的分组被改变），根据这个点的位置对lsum和rsum做出相应的变化。4.昨天维护前缀和的问题在于0 ~ 360°并不是一个离散的范围而是一个连续的范围，前缀数组的维护有难度。貌似也是可以的，但我懒得想了以下是AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 5e4+200;const int inf = 0x3f3f3f3f;using namespace std;struct points&#123; int x,y,val; double k;//斜率&#125;P[maxn];int n,T;ll lsum,rsum,ans;bool cmp(points a,points b)&#123; return a.k&gt;b.k;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; lsum = 0;rsum = 0; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; P[i].x &gt;&gt; P[i].y &gt;&gt; P[i].val; //计算出斜率 P[i].k = atan(1.0*P[i].y/P[i].x); //预设lsum和rsum状态 if(P[i].x &lt; 0) lsum += P[i].val; else rsum += P[i].val; &#125; //按斜率排序 sort(P,P+n,cmp); //预设ans状态 ans = lsum * rsum; //遍历，维护lsum、rsum和ans for(int i = 0; i &lt; n; ++i)&#123; if(P[i].x &gt; 0)&#123; lsum += P[i].val; rsum -= P[i].val; &#125; else&#123; lsum -= P[i].val; rsum += P[i].val; &#125; ans = max(ans,lsum*rsum); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B Build a tree我的数据结构是真的菜啊解题：显然，题目给出的是一个有n个节点的完全k叉树，观察这课树，不难发现，除了第一层和最后一层，每一层至多只有一棵子树不是满k叉树，而这棵子树左边的所有子树是满k叉树，右边是深度小一的满k叉树（画张图就很清楚了），因此按以下步骤求解：1.预处理，用一个数组记录每一层最后一个节点的编号，同时得到树的深度。2.首先单独处理最后一层，将可能不是满k叉树的那几个节点单独挑出，并标记最后一个节点，其余统一进行异或。3.向上遍历，每一层由三部分组成：①最深的满k叉树②不满的那棵k叉树③浅一层的k叉树。每次遍历一层将标记上传的父节点，这个节点就是那棵可能不满的k叉树，左边是较深的k叉树，右边是较浅的k叉树。很容易得到满k叉树的size和数目，因此统一异或。不满的k叉树的size等于这一层以下（包含这一层）的总节点数减去左边满k叉树的size之和再减去右边满k叉树的size之和。4.一直遍历到树的第一层，结束遍历。5.显然遍历的时间复杂度是$logk(n)$，只要k&gt;=2，是很快就能遍历完的，但当k=1是遍历会很慢，因此打表特判。下面给出AC代码，代码比较丑，将就一下吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int T;//num记录每一层最后一个节点的编号，pos是非满k叉树节点的编号//LSize是pos左边满k叉树的size，RSize同理//ex是单独处理的子树的异或结果,restSize是非满k叉树的sizell n,k,num[70],dep,pos,LSize,RSize,nowdep,ex,restSize;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res *= a; b &gt;&gt;= 1; a*=a; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; k; //特判k=1的情况 if(k == 1)&#123; ll tmp = n % 4; if(tmp == 0) cout &lt;&lt; n &lt;&lt; '\n'; if(tmp == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; if(tmp == 2) cout &lt;&lt; n+1 &lt;&lt; '\n'; if(tmp == 3) cout &lt;&lt; 0 &lt;&lt; '\n'; continue; &#125; else&#123; ll i = 0,ans = n; num[0] = 0; //找出每一层最后一个节点的编号以及树的深度 while(num[i] &lt; n - 1 &amp;&amp; num[i] &lt;= n - 1 - qpow(k,i+1))&#123; num[i+1] = num[i] + qpow(k,i+1); i++; &#125; pos = n - 1; //可能组成非满2叉树的节点数 restSize = (pos-num[i])%k; ans ^= (((pos-num[i])-restSize) &amp; 1); ex = ((restSize&amp;1)?1:0); //深度是i+1，原因自己看上面的while条件，主要是怕他溢出ll。。 dep = i + 1; //最后一层已经处理完，开始处理倒数第二层 nowdep = i; LSize = 1; RSize = 0; //ans初始化为n，因此不用再算第一层，算到第2层就可以结束了 while(nowdep &gt; 0)&#123; //上传标记 pos = (pos-1)/k; //计算左满k叉树，右满k叉树以及非满k叉树的size LSize = LSize * k + 1; RSize = RSize * k + 1; restSize = (n - 1 - num[nowdep-1])- (pos-num[nowdep-1]-1)*LSize - (num[nowdep]-pos)*RSize; ex ^= restSize; ans ^= (((pos-num[nowdep-1]-1)&amp;1)?1:0)*LSize; ans ^= (((num[nowdep]-pos)&amp;1)?1:0)*RSize; nowdep--; &#125; //最终结果异或上单独处理的子树 ans ^= ex; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; C Color the chessboard解题：昨天想的没错，只要2 * 2的矩形满足，整个图就能满足，将各种2 * 2的矩形排列一下，你或许会发现，将R看做1，B看做0，所有答案一定满足2种情况之一：1.不考虑列的情况，每一行一定是01循环或10循环之一。2.不考虑行的情况，每一列一定是01循环或10循环之一。其次，只要满足上述两种情况之一，那么一定是一种答案。因此分2次暴力跑出能否满足上述2种情况之一，将两种情况的可能数相加。有2种情况可能会被重复计算，也就是行和列同时满足01循环或10循环的情况，单独跑出能否满足这种情况，能满足则减一。具体可以结合这篇文章一起理解，我的代码也是几乎照抄了一遍这篇文章的。。以下是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll mod = 998244353;int T,n,m;ll ans,ans1,ans2;int M[2000][2000];char C[2000][2000];bool flag;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j)&#123; cin &gt;&gt; C[i][j]; if(C[i][j] == 'R') M[i][j] = 1; if(C[i][j] == 'B') M[i][j] = 0; if(C[i][j] == '?') M[i][j] = -1; &#125; ans1 = 1; for(int i = 1; i &lt;= n; ++i)&#123; //cnt是每一行选择的可能性，显然总的可能性要相乘得出 ll cnt = 0; flag = true; for(int j = 1; j &lt;= m; ++j)&#123; if(j%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if(j%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; flag = true; for(int j = 1; j &lt;= m; ++j)&#123; if(j%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if(j%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; ans1 = (ans1*cnt)%mod; if(ans1 == 0) break; &#125; ans2 = 1; for(int j = 1; j &lt;= m; ++j)&#123; ll cnt = 0; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; if(i%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if(i%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; if(i%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if(i%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; ans2 = (ans2*cnt)%mod; if(ans2 == 0) break; &#125; ans = (ans1+ans2)%mod; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= m; ++j)&#123; if((i+j)%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if((i+j)%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(!flag) break; &#125; if(flag) ans = (ans-1+mod)%mod; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= m; ++j)&#123; if((i+j)%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if((i+j)%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(!flag) break; &#125; if(flag) ans = (ans-1+mod)%mod; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 代码中的break都是用来剪枝的，剪枝以后变慢了，姑且是能懂了，不过总感觉有些不能释怀，比赛时真的能想通吗。。。 7/3补题小结今天暂时补到这了，感觉还是经验不够啊？？还是我太菜了这几题能看懂但总觉得比赛的时候想不到。]]></content>
      <categories>
        <category>ACM自闭日记</category>
      </categories>
      <tags>
        <tag>自闭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论最小生成树]]></title>
    <url>%2F2019%2F07%2F02%2FminTree%2F</url>
    <content type="text"><![CDATA[最小生成树本文会介绍两种用于获取最小生成树的算法，同样只给出用法不给出证明。 引入最小生成树通常用于解决形如以下的这种问题：给定若干个点和若干个边，保证这些边能将这些点全联通，试从这些边中选出部分边，使生成的树的边权之和最小。当然ACM的题通常都会有一个场景，比如有许多城镇，现已知这些城镇间的距离，要在这些城镇间修路，保证联通所有城镇的同时使得所修的路最短。 最小生成树算法下文会介绍两种算法Prim和Kruscal算法,这两种算法都会采用贪心的策略。 PrimPrim是一种以点为主体的贪心算法。下面简述算法的过程：1.在所有点中任取一点作为树的根，更新其他所有点到树的距离。2.在未被选取的点中，找到离树最近的点并选入树中，再次更新其他所有点到树的距离。3.重复第2步，直到所有点都被选入树中，Prim算法到此结束。点到树的距离是指点到树上任意一点的最短距离注意给出的图有多个最小生成树，根据选取的起点不同可能的到不同的最小生成树，但如果最小生成树唯一，那么起点的选取不会影响最终得到的最小生成树，所以放心大胆地去选取起点吧！ 下面给出prim算法主体的代码： 123456789101112131415161718192021222324void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125; 本算法中采用邻接矩阵以及暴力遍历找最小值的方式实现，理论上可以用优先队列和邻接表实现。 同样给出例题：hdu1233以下是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn = 200;const int inf = 0x3f3f3f3f;using namespace std;int N,dis[maxn][maxn],vis[maxn],ans,mndis[maxn];void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; N)&#123; if(!N) break; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); int T = N * (N - 1) / 2; while(T--)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; dis[a][b] = dis[b][a] = c; &#125; prim(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; KruscalKruscal是一种以边为主体的贪心算法，下面简述算法过程。1.从所有没有使用过的边中找出最短的一条边，标记为使用过了。2.如果边的两个端点不在一棵树中，那么将这条边加入到树中，否则不加入。3.重复1、2步直到所有点被联通（显然联通n个点需要n-1条边）。 找最短边的过程可以用优先队列实现，而判断端点是否在同一棵树中，可以用并查集实现，如果不会并查集，可以先阅读这篇文章，下面代码中的Find和Union函数毁在这篇文章中给出模版。下面给出Kruscal算法的主体代码： 12345678910111213141516171819void kruscal()&#123; int ans = 0,cnt = 0; //选取最短边直到没有边可以再选或者图已经联通 while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; //利用并查集判断是否在同一棵树中，如果不在则加入树中 if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; //没有选取到M-1条边（M为点的数量），说明图不能联通 if(cnt != M-1) puts("?"); //图已联通，输出最小边权和 else printf("%d\n",ans);&#125; 同样给出例题：hdu1683AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;const int maxn = 200;using namespace std;struct edge&#123; int from; int to; int val; edge(int a = 0,int b = 0,int c = 0)&#123;from=a;to=b;val=c;&#125; friend bool operator &gt; (edge a,edge b)&#123; return a.val &gt; b.val; &#125;&#125;;int N,M,father[maxn];priority_queue&lt; edge,vector&lt;edge&gt;,greater&lt;edge&gt; &gt; Q;int Find(int a)&#123; if(father[a]==a) return a; return father[a]=Find(father[a]);&#125;void Union(int a,int b)&#123; int f1=Find(a),f2=Find(b); father[f2] = f1;&#125;void init()&#123; for(int i = 1; i &lt;= M; ++i) father[i]=i; while(!Q.empty()) Q.pop();&#125;void kruscal()&#123; int ans = 0,cnt = 0; while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; if(cnt != M-1) puts("?"); else printf("%d\n",ans);&#125;int main()&#123; while(scanf("%d",&amp;N))&#123; if(N==0) break; scanf("%d",&amp;M); init(); for(int i = 0; i &lt; N; i++)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); Q.push(edge(a,b,c)); &#125; if(N&lt;M-1)&#123;puts("?");continue;&#125; kruscal(); &#125; return 0;&#125; 后记以上就是两种最短路算法的实现过程了。后记不知道写啥了，就这样吧]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论最短路]]></title>
    <url>%2F2019%2F07%2F01%2Fminpath%2F</url>
    <content type="text"><![CDATA[最短路算法本文将介绍几种用于解决最短路问题的算法，仅给出用法，不给出证明（因为不会证明）。 问题简述最短路问题：给出若干个点和若干个带有边权的边，要求找出从某点到某点的最短路径。 邻接表简单来说就是为每一个点建立一个边链表记录了与这个点所连的所有边。实现方法很多，本文用vector实现。 123//edge为边的结构体，maxn为点的总数，E[i]中记录了与点i相连的所有边//如果题目为无向图，注意要push_back两个方向的边vector&lt;edge&gt; E[maxn]; 单源最短路即仅要求求出从一个点到其他所有点（某一点）的最短距离的问题。 dijkstra我将dijkstra认识为一个贪心的BFS过程，首先，我们需要用到两个结构体。1.边，这个结构体必须包含目标点，边权，可以包含出发点（也可以不包含）。 12345struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;; 2.状态，这个结构体需要包含当前所在的位置（影响联通路径的状态）和已经走过的距离，同时重载&gt;号，比较的依据为走过的距离，重载&gt;号是为了能够使用priority_queue。 123456789struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;; 有了这两个结构体之后，我们就能开始dijkstra的主体了，简单地描述一下dijkstra的过程。1.录入数据。2.创建一个nod的优先队列，从小的开始出队列。3.将初始态（初始位置，经过的距离为0）push进优先队列，设初始最短路径都为无穷大。4.弹出队首元素，更新与队首位置相连的所有点，如果能够更新（距离变小了）某个点，则将这个点push进队列。5.重复第4步直到队列为空，这意味着没有点能够再次被更新了，dijkstra算法到此结束。下面给出算法主体代码： 12345678910111213141516171819202122232425void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; //优先队列，从较小的开始出 Q.push(nod(N,0));//初始态,N为出发点 //类似BFS过程 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; //若能更新，则更新并把更新的点push进队列 if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125; 需要注意的是，dijkstra算法并不能判断负环，因此当题目中出现负边时慎用。 这里给出一道例题：POJ2387AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int maxn = 1000+50;const int inf = 0x3f3f3f3f;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];int T,N,dis[maxn];//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....//加边，无向图时添加两条边void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); return;&#125;void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(N,0));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T &gt;&gt; N; while(T--)&#123; int from,to,val; cin &gt;&gt; from &gt;&gt; to &gt;&gt; val; add(from,to,val); &#125; dij(); cout &lt;&lt; dis[1] &lt;&lt; endl; return 0;&#125; 以下内容较难，可跳过此外，虽然在上题中dis[i]表示从起点到i点的最短距离，但实际上这个dis数组的下标代表的是一个状态，本题中状态只有所在的点，因此dis数组也只需要一个下标，dis数组的下标可以根据需要扩充。例如在hdu6071中，dis[i][j]表示的就是跑到了i点且跑过的距离模mod后为j的一个状态，我们也可以将每一种状态抽象为不同的点。同样给出AC代码（本题较难，可能另开文章单独解释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 6e5+20;const int mod = 998244353;const int inf = 0x3f3f3f3f;const ll llinf = 0x3f3f3f3f3f3f3f3f;using namespace std;struct edge&#123; ll from; ll to; ll val; edge(ll a = 0,ll b = 0,ll c = 0)&#123;from=a;to=b;val=c;&#125;&#125;;struct nod&#123; ll pos; ll d; nod(ll a=0,ll b=0)&#123;pos = a;d = b;&#125; friend bool operator &gt; (nod a,nod b)&#123; return a.d &gt; b.d; &#125;&#125;;ll T,k,d12,d23,d34,d41,m,dis[5][maxn];vector&lt;edge&gt; E[5];void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(2,0)); while(!Q.empty())&#123; nod t = Q.top(); Q.pop(); if(t.d &gt; dis[t.pos][t.d%m]) continue; for(vector&lt;edge&gt;::iterator it = E[t.pos].begin(); it != E[t.pos].end(); it++)&#123; ll nd = t.d+(*it).val; if(nd &lt; dis[(*it).to][nd%m])&#123; dis[(*it).to][nd%m] = nd; Q.push(nod((*it).to,nd)); &#125; &#125; &#125;｝int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; for(int i = 1; i &lt;= 4; ++i) E[i].clear(); cin &gt;&gt; k &gt;&gt; d12 &gt;&gt; d23 &gt;&gt; d34 &gt;&gt; d41; E[1].push_back(edge(1,2,d12));E[2].push_back(edge(2,1,d12)); E[2].push_back(edge(2,3,d23));E[3].push_back(edge(3,2,d23)); E[3].push_back(edge(3,4,d34));E[4].push_back(edge(4,3,d34)); E[4].push_back(edge(4,1,d41));E[1].push_back(edge(1,4,d41)); m = 2 * min(d12,d23); dij(); ll ans = llinf; for(int i = 0; i &lt; m; i++)&#123; if(dis[2][i] &gt;= k) ans = min(ans,dis[2][i]); else&#123; ll delt = k - dis[2][i]; dis[2][i] += (delt/m+(delt%m?1:0))*m; ans=min(ans,dis[2][i]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 至此，dijkstra算法的介绍告一段落。 SPFA(待补)同样为单源最短路算法，相较于dijkstra的优势是可以判断负环，劣势是比较慢。是优化版的Bellman-Ford算法。模版及例题待补 Bellman-Ford他死了。 多源最短路给定若干点以及点之间的距离(边)，要求求出任意两点间的最短距离。 Floyed算法又名Warshall算法。暴力遍历O($n^3$)次点，对于任意两点i,j，如果以k为桥梁能使i ~ j的距离变短，那么更新i ~ j的距离。由于算法特性，只能用邻接矩阵来存图。算法主体代码： 1234for(int k = 1; k &lt;= n; k++)for(int i = 1; i &lt;= n; i++)for(int j = 1; j &lt;= n; j++)w[i][j] = min(w[i][j], w[i][k] + w[k][j]); 给出一道例题：poj2139AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;typedef long long ll;const int inf = 0x3f3f3f3f;using namespace std;int w[303][303], tmp[303];int main()&#123; int n, m, t; scanf("%d %d", &amp;n, &amp;m); memset(w, inf, sizeof(w)); for(int i = 1; i &lt;= n; i++) w[i][i] = 0; while(m--) &#123; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; tmp[i]; &#125; for(int i = 0; i &lt; t; i++) for(int j = 0; j &lt; i; j++) w[tmp[i]][tmp[j]] = w[tmp[j]][tmp[i]] = 1; &#125; for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); double ans = inf; for(int i = 1; i &lt;= n; i++) &#123; int sum = 0; for(int j = 1; j &lt;= n; j++) sum += w[i][j]; ans = min(ans, sum * 100 * 1.0/ (n - 1)); &#125; printf("%d\n", (int)ans); return 0;&#125; 非常简单的一个算法，但是他的空间复杂度和时间复杂度都过高，并不常用。 后记好吧，从篇幅上可以看出，最短路算法中最常用，最强大的算法就是dijkstra了，他的变形也有很多，需要好好掌握哦！本文中一些STL会在将来的文章里补上用法。emmm可能会吧]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>图论</tag>
        <tag>最短路问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2019%2F07%2F01%2FTrie%2F</url>
    <content type="text"><![CDATA[TrieTrie，也叫做字典树，是一种树形结构，可以高效的存储字符串和查询字符串。 Trie比较简单，这里只做简单的介绍，并给出例题和模版。例题：hdu1251题意简述：给定一系列字符串，再给出多个前缀，输出这些前缀在多少个字符串中出现过。 Trie的组成这种树形结构只有一个根节点，根节点没有意义（虚节点）。网上很多文章中将每一个节点视为一个字符，但事实并非如此，在Trie中，每一条边代表了一个字符，而从根节点走到某一节点路径上所有字符组成的字符串，则为该节点所代表的字符串。为了方便讲解，这里直接给出Trie节点的定义： 123456789101112struct trie&#123; trie *nxt[26]; //子节点的指针数组，此处26为字符集的大小，可以根据需求修改 int cnt; //此题用于统计前缀，根据需求修改 //初始化 trie() &#123; cnt = 1; //初始化所有nxt为NULL memset(nxt,NULL,sizeof(nxt)); &#125;&#125;; 我们可以认为，从一个节点p到节点p-&gt;nxt[id]的边所代表的字符即为id所映射的字符。以a ~ z映射到0 ~ 25为例，root-&gt;nxt[0]-&gt;nxt[1]-&gt;nxt[2]节点所代表的的字符串就是abc。 Trie的构建与线段树不同，Trie并不是输入完所有字符串后统一构建的(当然你想这么做也是可以的，但是会MLE),Trie的构建通常是输入一个字符串就插入一个字符串，插入的过程很简单，如果nxt[id]已经存在就沿着走，如果不存在就新建一个。以下为代码实现： 12345678910111213141516171819202122void Insert(char *s)&#123; trie *p = root; i = 0; //遍历字符串 while(s[i])&#123; id = s[i] - 'a'; //如果存在，就沿着走，并操作路径上的统计量（此处用于统计前缀） if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; //如果不存在，就新建，当然也要走过去 else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125; Trie的查询字典树的查询视题意而定，在本次例题中，为统计前缀出现的次数。根据字符串沿着树遍历即可，若遇到nxt[id]==NULL的情况，说明没找到，直接返回0。以下为代码实现 12345678910111213141516int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; //找得到就沿着走 if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; //找不到直接返回0 else return 0; i++; &#125; //若找到了，返回最终节点的cnt值 return p -&gt; cnt;&#125; Trie的删除递归删除即可 123456void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125; 例题+模版回到例题的解答，解题过程非常简单毕竟是模版题1.根据给出的字符串建立Trie2.根据前缀在Trie上遍历 AC代码（模版）：本题用C++提交的，用G++提交有惊喜哦本题G++提交会MLE，请用C++提交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const int maxn = 11;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; int cnt; trie() &#123; cnt = 1; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int i,id;char S[maxn],s1[maxn];void Insert(char *s)&#123; trie *p = root; i = 0; while(s[i])&#123; id = s[i] - 'a'; if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125;int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; else return 0; i++; &#125; return p -&gt; cnt;&#125;void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125;int main()&#123; root = new trie; while(scanf("%s",S))&#123; Insert(S); cin.get(); if(cin.peek() == '\n') break; &#125; while(scanf("%s",s1) != EOF)&#123; printf("%d\n",query(s1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F07%2F01%2FACautoman%2F</url>
    <content type="text"><![CDATA[AC自动机AC自动机，用于多模字符串匹配，类似KMP+Trie。 一种最常见的题目如下（裸题模版）题意简述：首先输入多个单词（模式串），接着输入一串目标字符串，输出有多少个模式串在目标字符串中出现过。解题步骤：1.根据给出的模式串构造一个Trie树。2.在Trie树上构造fail指针（构造Trie图）。3.将目标字符串在Trie图上进行匹配。 Fail指针Fail指针的构造过程：1.用BFS的顺序逐层向下构造Fail指针。2.当一个节点的父亲指针为Root时，将Fail指针指向Root。3.当要获取一个节点（父节点不为Root）的Fail指针时，从其父亲指针的Fail指针开始查找与自己同名的子节点，若找到，则这个节点的Fail指针指向该与自己同名的子节点；若找不到，则沿着Fail指针继续寻找直到找到或直到指向Root时仍找不到。若指向根节点时仍然找不到，及当前节点没有Fail指针，将Fail指针指向Root。具体代码如下： 12345678910111213141516171819202122232425262728293031323334void getFail()&#123; queue&lt;trie*&gt; q; //用于BFS q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; //父节点为root的节点fail指针指向root if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; //从父节点的fail指针开始查找 temp = p -&gt; fail; //当temp为NULL时即没有找到同名的子节点 while(temp)&#123; //找到了与自己同名的子节点，则让当前节点的fail指向该子节点，同时结束循环 if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; //沿着fail指针继续查找 temp = temp -&gt; fail; &#125; //temp为NULL，即没有找到同名的子节点，将fail指针指向root if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; //bfs q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125; Fail指针具有的特点：1.从任意节点沿着fail指针遍历，总能回到root节点。2.一个节点的fail指针指向的节点所代表的字符串，为当前节点字符串的某一后缀，因此当匹配时匹配到某一节点时，这一节点fail指针所指向的字符串也一定出现过了，所以在匹配过程中每匹配一个字符，要沿着fail指针跳回root（例如当匹配到abcd时，bcd,cd,d都一定已经出现过了）。3.这个性质与KMP中的next数组很想，可以结合理解。下图是一张构建好的fail指针的图： 查询过程查询步骤：1.如果当前字符匹配，则沿着nxt[id]向下走；如果当前字符不匹配，则沿着fail指针查找nxt[id]直到找到或指向root。2.每匹配完一个字符，沿着fail指针跳回root同时统计路径上出现的单词数。3.将匹配过的模式串打上标记避免重复统计。具体代码如下： 12345678910111213141516171819202122232425int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; //遍历字符串s while(s[i])&#123; //26个小写字母映射到0~25 int id = s[i] - 'a'; //若没有找到nxt[id]且当前指针没有指向root（root的fail指针为NULL），则沿着fail指针遍历直到找到或指向root while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; //若p==NULL，说明最终都没有找到，让p指向root if(p == NULL) p = root; //从p开始跳fail指针统计路径上的单词数 temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; //统计后打上标记（清零单词数量） temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125; 例题+模版hdu2222题意简述：首先输入多个单词（模式串），接着输入一个目标字符串，输出有多少个模式串在目标字符串中出现过。以下为AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;typedef unsigned long long ull;const int P = 1e9+7;const int maxn = 5e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; trie *fail; int cnt; //计算前缀时可用，本题无用 int flag; //记录当前节点结束的字符串个数 trie()&#123; cnt = 1; flag = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int T,N,Q;char S[maxn],s1[maxn],s2[maxn];void Insert(char *s)&#123; trie *p = root; int len = strlen(s); for(int i = 0; i &lt; len; i++)&#123; int id = s[i] - 'a'; if(p-&gt;nxt[id] != NULL)&#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else&#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; p -&gt; flag++;&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; temp = p -&gt; fail; while(temp)&#123; if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; while(s[i])&#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125;//递归释放Trievoid Free(trie *p)&#123; for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; root = new trie; scanf("%d",&amp;N); while(N--) &#123; scanf("%s",S); Insert(S); &#125; getFail(); scanf("%s",s1); printf("%d\n",query(s1)); Free(root); &#125;&#125;]]></content>
      <categories>
        <category>ACM算法基础</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
</search>
