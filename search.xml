<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F07%2F01%2FACautoman%2F</url>
    <content type="text"><![CDATA[AC自动机AC自动机，用于多模字符串匹配，类似KMP+Trie。 一种最常见的题目如下（裸题模版）题意简述：首先输入多个单词（模式串），接着输入一串目标字符串，输出有多少个模式串在目标字符串中出现过。解题步骤：1.根据给出的模式串构造一个Trie树。2.在Trie树上构造fail指针（构造Trie图）。3.将目标字符串在Trie图上进行匹配。 Fail指针Fail指针的构造过程：1.用BFS的顺序逐层向下构造Fail指针。2.当一个节点的父亲指针为Root时，将Fail指针指向Root。3.当要获取一个节点（父节点不为Root）的Fail指针时，从其父亲指针的Fail指针开始查找与自己同名的子节点，若找到，则这个节点的Fail指针指向该与自己同名的子节点；若找不到，则沿着Fail指针继续寻找直到找到或直到指向Root时仍找不到。若指向根节点时仍然找不到，及当前节点没有Fail指针，将Fail指针指向Root。具体代码如下： 12345678910111213141516171819202122232425262728293031323334void getFail()&#123; queue&lt;trie*&gt; q; //用于BFS q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; //父节点为root的节点fail指针指向root if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; //从父节点的fail指针开始查找 temp = p -&gt; fail; //当temp为NULL时即没有找到同名的子节点 while(temp)&#123; //找到了与自己同名的子节点，则让当前节点的fail指向该子节点，同时结束循环 if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; //沿着fail指针继续查找 temp = temp -&gt; fail; &#125; //temp为NULL，即没有找到同名的子节点，将fail指针指向root if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; //bfs q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125; Fail指针具有的特点：1.从任意节点沿着fail指针遍历，总能回到root节点。2.一个节点的fail指针指向的节点所代表的字符串，为当前节点字符串的某一后缀，因此当匹配时匹配到当前节点时，当前节点fail指针所指向的字符串也一定出现过了，所以在匹配过程中每匹配一个字符，要沿着fail指针跳回root。 查询过程查询步骤：1.如果当前字符匹配，则沿着nxt[id]向下走；如果当前字符不匹配，则沿着fail指针查找nxt[id]直到找到或指向root。2.每匹配完一个字符，沿着fail指针跳回root同时统计路径上出现的单词数。3.将匹配过的模式串打上标记避免重复统计。具体代码如下： 12345678910111213141516171819202122232425int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; //遍历字符串s while(s[i])&#123; //26个小写字母映射到0~25 int id = s[i] - 'a'; //若没有找到nxt[id]且当前指针没有指向root（root的fail指针为NULL），则沿着fail指针遍历直到找到或指向root while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; //若p==NULL，说明最终都没有找到，让p指向root if(p == NULL) p = root; //从p开始跳fail指针统计路径上的单词数 temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; //统计后打上标记（清零单词数量） temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125; 例题+模版hdu2222题意简述：首先输入多个单词（模式串），接着输入一个目标字符串，输出有多少个模式串在目标字符串中出现过。以下为AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;typedef unsigned long long ull;const int P = 1e9+7;const int maxn = 5e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; trie *fail; int cnt; //计算前缀时可用，本题无用 int flag; //记录当前节点结束的字符串个数 trie()&#123; cnt = 1; flag = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int T,N,Q;char S[maxn],s1[maxn],s2[maxn];void Insert(char *s)&#123; trie *p = root; int len = strlen(s); for(int i = 0; i &lt; len; i++)&#123; int id = s[i] - 'a'; if(p-&gt;nxt[id] != NULL)&#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else&#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; p -&gt; flag++;&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; temp = p -&gt; fail; while(temp)&#123; if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; while(s[i])&#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125;//递归释放Trievoid Free(trie *p)&#123; for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; root = new trie; scanf("%d",&amp;N); while(N--) &#123; scanf("%s",S); Insert(S); &#125; getFail(); scanf("%s",s1); printf("%d\n",query(s1)); Free(root); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>kmp</tag>
        <tag>trie</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
</search>
