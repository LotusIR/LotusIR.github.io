[{"title":"ICPC随笔","date":"2019-09-08T16:30:58.000Z","path":"2019/09/09/icpc20190909/","text":"好久没更新了。。打了几场ICPC网络赛，把一些收获写一下记录一下吧 离散化当数据很大而询问较小时，常常用到的方法，只考虑被询问的元素，以前写的离散化过于暴力，这里整理一个简单的模版。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7+100;//num是将a数组升序后去重的数组，n为a的元素数，cnt是num数组的元素数。int a[maxn],num[maxn],cnt,n;//idx用于获取a被离散化后x的id。int idx(int x)&#123; return lower_bound(num,num+cnt,x)-num;&#125;int main()&#123; //录入a的数据，复制到num中 cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a[i]; num[i]=a[i]; &#125; //离散化过程 sort(num,num+n); cnt = unique(num,num+n)-num;&#125;","tags":[{"name":"离散化","slug":"离散化","permalink":"https://lotusir.github.io/tags/离散化/"},{"name":"链式前向星","slug":"链式前向星","permalink":"https://lotusir.github.io/tags/链式前向星/"}]},{"title":"暑期集训——KMP和字典树","date":"2019-08-03T07:30:35.000Z","path":"2019/08/03/TrainString/","text":"还不知道KMP原理只会用的路过。。 前言在讲题之前，说一下next[]数组的含义，next[i]是指在第i个位置前（不包含i）的最大前后缀长度。 以及一个结论：设有字符串str，使len=strlen(str)以及length=len-next[len]，如果len%length==0，那么这个str是一个循环字符串，且循环节的长度为len/length。至于原理：quote 假设我们有一个字符串ababab,那么next[6]=4对吧，由于next的性质是，匹配失败后，下一个能继续进行匹配的位置，也就是说，把字符串的前四个字母，abab,平移2个单位，这个abab一定与原串的abab重合（否则就不满足失败函数的性质），这说明了什么呢，由于字符串进行了整体平移，而平移后又要重叠，那么必有s[1]=s[3],s[2]=s[4],s[3]=s[5],s[4]=s[6].说明长度为2的字符串在原串中一定重复出现，这就是len-next[len]的含义！ unquote好了就是这些，接着看一下题吧。（代码都共享了） A Hat’s Words(hdu-1247)题目地址：vj题意：给若干个单词，若其中的一个单词是由另外两个单词拼成的，那么称这个单词为hat’s word，要求按字典序输出所有的hat’s word。解题：一开始没什么思路，查了一下百度，发现这题真的是有够暴力。。用给出的所有单词建立字典树，接着对每一个单词的每一种分割，都在字典树上搜索，如果被分割的两边都能被搜索到，那么就是hat’s word，数据比较弱，速度很快，记得按字典序输出，可以用sort排序也可以用set存下后输出。 B 统计难题(hdu-1251)题目地址：vj题意：给若干个单词和若干个前缀，对于每一个前缀，要求输出它在多少个单词中是前缀。解题：字典树板子题（我的模版就是照着这道题打的），插入单词时每经过一个节点就让这个节点的cnt加一，搜索时前缀的结束节点的cnt数就是答案。tips：这道题如果用G++交可能会MLE，用C++交就不会，好像是内存管理方法的问题。 C Phone List(hdu-1671)题目地址：vj题意：给若干个数字串，如果他们之间有两个数字串有公共前缀，那么输出NO，否则输出YES。解题：和B类似，建立完字典树后搜索每一个数字串，如果搜索路径上某一节点的cnt大于等于2，那么就存在公共前缀。 D 单词数(hdu-2072)题目地址：vj题意：给一篇文章，统计文章中不同单词的数量。解题：解法一：直接用set存单词，最后set.size()就是答案。解法二：用单词建立字典树，每次插入新的单词时在末节点打上记号并让ans++，如果已经被打上记号说明是重复的单词。tips：用字典树做这道的话注意一下输入格式，我前几次不知道为啥wa了，改成sstream输入过了。 E Oulipo(hdu-1686)题目地址：vj题意：给一个模式串，给一个主串，问模式串在主串中出现了几次（可以重叠）。解题：KMP算法经典例题，在模式串匹配成功后ans++，让模式串的指针j指向next[j]即可。参考博客：https://shu-ssyze.github.io/2019/07/03/KMP-Algorithm/ F Seek the Name, Seek the Fame(poj-2752)题目地址：vj题意：给一个字符串，输出这个字符串所有满足既是前缀又是后缀的子串的长度。解题：还记得next[i]的含义吗？next[i]是在i位置之前最大公共前后缀的长度，那么我们从next[len]开始遍历直到遍历到0，就是这个字符串所有公共前后缀的长度，最后倒序输出一下就可以了。（如果看不懂可以对着代码自己模拟一下）AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e6 + 5;char p[maxn];int t;int next1[maxn+1];int ans[maxn];void getNext()&#123; int plen = strlen(p); int j = 0, k = -1; next1[0] = -1; while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; next1[j] = k; &#125; else k = next1[k]; &#125;&#125;int main()&#123; while(~scanf(\"%s\",p))&#123; getNext(); int len = strlen(p); int tmp = next1[len],cnt=0; while(tmp != 0)&#123; ans[cnt++]=tmp; tmp=next1[tmp]; &#125; for(int i = cnt-1; i &gt;= 0; --i) printf(\"%d \",ans[i]); printf(\"%d\\n\",len); &#125;&#125; G 剪花布条(hdu-2087)题目地址：vj题意：给一个模式串和一个主串，问模式串在主串中出现了几次(不可重叠)。解题：仍然是KMP，与E题类似，只不过这一次匹配成功后不再让j指向next[j]而是直接指向0。 H Period(poj-1961)题目地址：vj题意：给一个字符串，问这个字符串从头开始的子串中，有多少个子串是循环字符串(诸如”abab”,”abcabc”，”abababab”的就是循环字符串，即可由某一个循环节字符串组成)，输出这些子串的长度和循环节循环的次数。解题：还记得前言中的结论吗？对字符串的每一个位置应用那个结论就能的到答案了（不懂得再去看两遍，再不懂。。就把结论记住吧）tips: 即使能被整除，整除的结果有可能是1，这种情况我们并不认为他是循环字符串，记得特判一下。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e6 + 5;char p[maxn];int t;int next1[maxn];void getNext()&#123; int plen = strlen(p); int j = 0, k = -1; next1[0] = -1; while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; next1[j] = k; &#125; else k = next1[k]; &#125;&#125;int main()&#123; int kase = 0; while(scanf(\"%d\",&amp;t) &amp;&amp; t)&#123; scanf(\"%s\",p); getNext(); int len = strlen(p); printf(\"Test case #%d\\n\",++kase); for(int i = 2; i &lt;= len; ++i)&#123; int length = i-next1[i]; if(i % length || i/length == 1) continue; else printf(\"%d %d\\n\",i,i/length); &#125; puts(\"\"); &#125;&#125; I Power Strings(poj-2406)题目地址：vj题意：给一个字符串，如果它是一个循环字符串，输出他的最大循环节循环的次数，否则输出1（即循环节为字符串本身）。解题：与H题相同，而且这次不用对每个子串应用那个结论了。AC代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e6 + 5;char p[maxn];int t;int next1[maxn];void getNext()&#123; int plen = strlen(p); int j = 0, k = -1; next1[0] = -1; while(j &lt; plen) &#123; if(k == -1 || p[k] == p[j]) &#123; ++j; ++k; next1[j] = k; &#125; else k = next1[k]; &#125;&#125;int main()&#123; while(~scanf(\"%s\",p))&#123; if(p[0]=='.') break; getNext(); int len = strlen(p); int length = len - next1[len]; if(len % length) puts(\"1\"); else printf(\"%d\\n\",len/length); &#125;&#125; 好了就到这里，今天题比较友好，大概是人生第一次AK吧hhhhhhh","tags":[{"name":"KMP","slug":"KMP","permalink":"https://lotusir.github.io/tags/KMP/"},{"name":"字典树","slug":"字典树","permalink":"https://lotusir.github.io/tags/字典树/"}]},{"title":"暑期集训——图论1（最短路、最小生成树）","date":"2019-08-02T14:54:36.000Z","path":"2019/08/02/TrainTulun1/","text":"卑微的我只做了板子题。。更新一个一句话题解的博客？ A Networking(POJ-1287)题目地址：VJ题意：裸的不能再裸的最小生成树题，prim或kruscal任选一个就能过了，记得重边时取最短边。 B Constructing Roads(POJ-2421)题目地址：VJ题意：最小生成树，但是有一些边已经被添加了，要求求出还需添加多少边才能形成最小数。解题：用kruscal，对于已经被添加的边，额外添加一条权值为0的边即可。 C Building a Space Station(POJ-2031)题目地址：VJ题意：给出若干个球，对于每个球，给出它的x,y,z坐标以及它的半径r，有重叠部分的球我们认为已经连通，在此基础上求最小生成树。解题：kruscal或prim都可以，两个球之间的边的长度是max(d-r1-r2,0)，d为两个球球心的距离，n^2的到边即可。 D Til the Cows Come Home(POJ-2387)题目地址：vj题意：最短路裸题，跑一遍dij就可以了。 E Invitation Cards(POJ-1511)题目地址：vj题意：给若干个点，问从出发点到这些点再回来至少需要多少距离（如果要到2和3，那么必须经过1→2→1→3→1，即使在走到2的过程中走到3也一样），数据保证可以从任何点到达任何点。解题：正向边跑一遍最短路，反向边再跑一遍最短路，把所有最短路相加就是答案（可以思考一下为什么，其实也不是很难理解，重点是数据保证可以从任何点到达任何点）。tips：由于这道题的数据量十分大，建议使用链式前向星存图，如果使用邻接表存图，那么请事先记录下每一条边的信息重复利用同一个邻接表多次赋值，使用两个邻接表跑两边最短路会超时（我也不知道为什么。。）。链式前向星的代码就不给了，用链式前向星基本不可能T，不管用SPFA还是DIJ都一样，这里给出邻接表的代码。AC代码：(运行时间约5000ms) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;typedef long long ll;const int maxn = 1e6+5;const int inf = 0x3f3f3f3f;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0):to(a),val(b)&#123;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0):pos(a),d(b)&#123;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q;int T,N,M,dis[maxn],from[maxn],to[maxn],val[maxn];ll ans;void dij()&#123; memset(dis,inf,sizeof(dis)); dis[1]=0; Q.push(nod(1,0));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125; for(int i = 1; i &lt;= N; ++i) ans+=dis[i];&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d%d\",&amp;N,&amp;M); for(int i = 0; i &lt; M; ++i)&#123; int f,t,v; scanf(\"%d%d%d\",&amp;f,&amp;t,&amp;v); from[i]=f;to[i]=t;val[i]=v; E[from[i]].push_back(edge(to[i],val[i])); &#125; ans = 0; dij(); for(int i = 1; i &lt;= N; ++i) E[i].clear(); for(int i = 0; i &lt; M; ++i) E[to[i]].push_back(edge(from[i],val[i])); dij(); for(int i = 1; i &lt;= N; ++i) E[i].clear(); printf(\"%lld\\n\",ans); &#125; return 0;&#125; F Heavy Transportation(POJ-1797)题目地址：VJ题意：给若干个点和边，求一条从1号点到N号点的路径，使路径上最长边的值最大。解题：类似最短路，只不过最短路的定义变了。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int maxn = 1000+50;const int inf = 1e6;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &lt; (nod a, nod b)&#123; return a.d&lt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];int T,N,dis[maxn],m,kase;//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....//加边，无向图时添加两条边void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); return;&#125;void dij()&#123; memset(dis,0,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt; &gt; Q; Q.push(nod(1,inf));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &lt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = min(d,val); if(nd &gt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; N &gt;&gt; m; while(m--)&#123; int f,t,v; cin &gt;&gt; f &gt;&gt; t &gt;&gt; v; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); &#125; dij(); cout &lt;&lt; \"Scenario #\" &lt;&lt; ++kase &lt;&lt; \":\\n\"; cout &lt;&lt; dis[N] &lt;&lt; endl &lt;&lt; endl; memset(dis,0,sizeof(dis)); for(int i = 1; i &lt;= N; ++i) E[i].clear(); &#125;&#125; G Arbitrage(POJ-2240)题目地址：VJ题意：能不能套汇？解题：floyd裸题（以前的代码对每一个点做Bellman-Ford竟然过了hdu的这题。。POJ这题只能用floyd）。 H Wormholes(poj-3259)题目地址：VJ解题：SPFA判负环裸题。 I Subway(POJ-2502)题目地址：VJ题意：小明要从家到学校，可以走路或走地铁，给出家、学校、地铁站的坐标（有多条地铁），求到学校至少要多久。解题：最短路，家为1号点，学校为2号点，地铁站为后面的点，同一条地铁线路上的点之间的时间为距离/地铁速度，除此之外的为距离/步行速度，最后从1号点到2号点的最短时间就是答案。tips：需要注意的是这道题里的距离是欧几里得距离而不是曼哈顿距离，以及注意单位的换算。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 1000+50;const int inf = 0x3f3f3f3f;const double subspeed = 40 * 1000 / 60;const double conspeed = 10 * 1000 / 60;using namespace std;struct point&#123; double x,y; point(double a=0,double b=0):x(a),y(b)&#123;&#125;&#125;po[maxn];struct edge&#123; int to; double val; edge(int a = 0,double b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; double d; nod(int a = 0,double b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];int N;//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....double dis[maxn];//加边，无向图时添加两条边void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); return;&#125;void dij()&#123; for(int i = 1; i &lt;= N; ++i) dis[i] = 1e10; priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(1,0));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; double d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; double val = E[pos][i].val; double nd = d + val; if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; po[1].x &gt;&gt; po[1].y; cin &gt;&gt; po[2].x &gt;&gt; po[2].y; N=2; double tx,ty; while(true)&#123; double ttlen = 0; bool flag=0; int st = N+1; while(cin &gt;&gt; tx &gt;&gt; ty)&#123; if(tx==-1 &amp;&amp; ty==-1) break; N++; po[N].x=tx;po[N].y=ty; if(flag==0) flag=1; else&#123; double dx = abs(tx-po[N-1].x),dy = abs(ty-po[N-1].y); double dis = sqrt(dx*dx+dy*dy); E[N].push_back(edge(N-1,dis/subspeed)); E[N-1].push_back(edge(N,dis/subspeed)); &#125; &#125; if(cin.peek()==EOF) break; &#125; for(int i = 1; i &lt;= N; ++i) for(int j = i+1; j &lt;= N; ++j)&#123; double dx = abs(po[i].x-po[j].x),dy = abs(po[i].y-po[j].y); double dis = sqrt(dx*dx+dy*dy); E[i].push_back(edge(j,dis/conspeed)); E[j].push_back(edge(i,dis/conspeed)); &#125; dij(); cout &lt;&lt; round(dis[2]) &lt;&lt; endl; return 0;&#125; 就到这了，后面两题还没做，也不想补。。（咸鱼.jpg）","tags":[{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://lotusir.github.io/tags/最小生成树/"},{"name":"最短路问题","slug":"最短路问题","permalink":"https://lotusir.github.io/tags/最短路问题/"}]},{"title":"暑期集训——线段树篇","date":"2019-07-31T10:55:24.000Z","path":"2019/07/31/TrainSegTree/","text":"线段树还是一个很神奇的东西，对区间加法有了新的认识。 VJ帐号：LotusIR，代码基本上都共享了（除了少数实在觉得丢脸的）。很多代码直接复制的板子，有比较多的注释，可以忽略。今天正好有空就把这个补了吧比赛地址：VJ A HDU-1166线段树单点加减和查询板子题，不贴代码了，占空间。。 B HDU-1754同A，这题是单点直接修改的。 C HDU-1394题意自己看吧。解题：总而言之统计出初始状态下数列中的逆序对，你可以用归并排序统计，当然今天的主题是线段树，所以就用权值线段树统计吧。接着开始滚动，我们很容易发现，如果我们把开头的第一个数a1放到数列的末尾，那么会多出n-1-a1个逆序对，同时会减少a1个逆序对，滚动一遍这个数列每次更新答案就能的到最小值了。AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5000+200;int tree[maxn],a[maxn],n;void pushup(int rt)&#123; tree[rt] = tree[rt&lt;&lt;1] + tree[rt&lt;&lt;1|1];&#125;//插入一个数字void Insert(int x,int l, int r, int rt)&#123; if(l==r)&#123;tree[rt]++;return;&#125; int m = (l+r) &gt;&gt; 1; if(x &lt;= m) Insert(x,l,m,rt&lt;&lt;1); else Insert(x,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//查询某个区间中数字出现的次数int queryseg(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return tree[rt]; int res = 0; int m = (l+r) &gt;&gt; 1; if(L &lt;= m) res += queryseg(L,R,l,m,rt&lt;&lt;1); if(R &gt;= m+1) res += queryseg(L,R,m+1,r,rt&lt;&lt;1|1); return res;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; n)&#123; memset(tree,0,sizeof(tree)); int sum = 0; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; Insert(a[i],0,n-1,1); sum+=queryseg(a[i]+1,n-1,0,n-1,1); &#125; int ans = sum; for(int i = 1; i &lt;= n; ++i)&#123; sum += n-1-a[i]; sum -= a[i]; ans = min(ans,sum); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D HDU-1698区间改值的求和线段树板子题，不贴代码了。 E POJ-3468同D，这题是区间加减的板子题。 F POJ-2777状态压缩的线段树，还挺有意思的。题意还是自己看~解题：线段树的节点上存储一个统计量，表示这个线段中所有的颜色的种类。具体的说，如果这个区间上有1,2,3,4，那么这个统计量就是0b1111(二进制，存下来以后是一个int或者ll)，同样的，如果有1,3而没有2,4,那么这个统计量就是0b0101，由于颜色的种类小于30种，所以用int就能存了，以防万一可以用ll，在区间合并的时候采用按位或运算(|)就可以了。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstring&gt;#define FAST ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)typedef long long ll;const int maxn = 1e5+300;const int inf = 0x3f3f3f3f;using namespace std;ll N,a[maxn],Sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],T,O;//更新当前节点void pushup(int rt)&#123; Sum[rt] = Sum[rt&lt;&lt;1] | Sum[rt&lt;&lt;1|1];&#125;//下传函数void pushdown(int l,int r,int rt)&#123; //区间改值 if(lazy[rt])&#123; lazy[rt&lt;&lt;1] = lazy[rt]; lazy[rt&lt;&lt;1|1] = lazy[rt]; Sum[rt&lt;&lt;1] = lazy[rt]; Sum[rt&lt;&lt;1|1] = lazy[rt]; lazy[rt] = 0; &#125; //区间增减 /*if(lazy[rt])&#123; int m = (l+r) &gt;&gt; 1; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; Sum[rt&lt;&lt;1] += lazy[rt] * (m-l+1); Sum[rt&lt;&lt;1|1] += lazy[rt] * (r-m); lazy[rt] = 0; &#125;*/&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号void build(int l,int r,int rt)&#123; if(l == r)&#123; Sum[rt] = a[l]; return; &#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 [L,R]查询的区间ll query(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return Sum[rt]; int m = (l+r) &gt;&gt; 1; ll res = 0; pushdown(l,r,rt); if(L &lt;= m) res |= query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) res |= query(L,R,m+1,r,rt&lt;&lt;1|1); return res;&#125;void segupdate(int L,int R,int l,int r,int rt,int lzy)&#123; if(L &lt;= l &amp;&amp; R &gt;= r)&#123; //区间改值 lazy[rt]=lzy; Sum[rt]=lzy; //区间加减 /*lazy[rt]+=lzy; sum[rt]+=(r-l+1) * lzy;*/ return; &#125; int m = (l+r) &gt;&gt; 1; pushdown(l,r,rt); if(L &lt;= m) segupdate(L,R,l,m,rt&lt;&lt;1,lzy); if(R &gt; m) segupdate(L,R,m+1,r,rt&lt;&lt;1|1,lzy); pushup(rt); return;&#125;int getans(ll a)&#123; int cnt = 0; while(a)&#123; if(a&amp;1) cnt++; a &gt;&gt;= 1; &#125; return cnt;&#125;int main()&#123; FAST; cin &gt;&gt; N &gt;&gt; T &gt;&gt; O; memset(lazy,0,sizeof(lazy)); for(int i = 1; i &lt;= N; ++i) a[i]=1; build(1,N,1); char op; while(O--)&#123; cin &gt;&gt; op; if(op=='C')&#123; int L,R,C; cin &gt;&gt; L &gt;&gt; R &gt;&gt; C; if(L&gt;R) swap(L,R); segupdate(L,R,1,N,1,(1&lt;&lt;(C-1))); &#125; else if(op=='P')&#123; int L,R; cin &gt;&gt; L &gt;&gt; R; if(L&gt;R) swap(L,R); cout &lt;&lt; getans(query(L,R,1,N,1))&lt;&lt;endl; &#125; &#125;&#125; G HDU-1542矩形平面交面积，还没做也还没看，下次看情况更新吧，如果还有下次的话 H HDU-4027区间开根号，按照ppt上的做法找着码就能过了。其实就是在暴力修改每一个值的基础上加了一个剪枝。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define FAST ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)typedef long long ll;const int maxn = 1e5+300;const int inf = 0x3f3f3f3f;using namespace std;ll N,M,a[maxn],Sum[maxn&lt;&lt;2],T,X,Y,kase;//更新当前节点void pushup(int rt)&#123; Sum[rt] = Sum[rt&lt;&lt;1] + Sum[rt&lt;&lt;1|1];&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号void build(int l,int r,int rt)&#123; if(l == r)&#123; Sum[rt] = a[l]; return; &#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 [L,R]查询的区间ll query(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return Sum[rt]; int m = (l+r) &gt;&gt; 1; ll res = 0; if(L &lt;= m) res += query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) res += query(L,R,m+1,r,rt&lt;&lt;1|1); return res;&#125;void segupdate(int L,int R,int l,int r,int rt)&#123; if(l==r)&#123;Sum[rt] = floor(sqrt(Sum[rt]));return;&#125; if(query(l,r,1,N,1)==r-l+1) return; int m = (l+r) &gt;&gt; 1; if(L &lt;= m) segupdate(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) segupdate(L,R,m+1,r,rt&lt;&lt;1|1); pushup(rt); return;&#125;int main()&#123; FAST; while(cin &gt;&gt; N)&#123; cout &lt;&lt; \"Case #\" &lt;&lt; ++kase &lt;&lt; \":\\n\"; for(int i = 1; i &lt;= N; ++i) cin &gt;&gt; a[i]; build(1,N,1); cin &gt;&gt; M; while(M--)&#123; cin &gt;&gt; T &gt;&gt; X &gt;&gt; Y; if(X&gt;Y) swap(X,Y); if(T==0) segupdate(X,Y,1,N,1); if(T==1) cout &lt;&lt; query(X,Y,1,N,1) &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125;&#125; I HYSBZ-1018神奇的一道题，线段树的节点维护区间内4个顶点的连通性以及中点的联通性，合并区间时按着图合并就行了。（应该可以用向右的延伸性代替中点的联通性，带我改了没过，可能还有啥细节吧。。）AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e5+300;const int inf = 0x3f3f3f3f;using namespace std;int N;struct node&#123; bool lt_rt; bool lt_rb; bool lt_lb; bool lb_rt; bool lb_rb; bool rt_rb; bool t_m; bool b_m;&#125;tree[maxn &lt;&lt; 2];void pushup(node &amp;now,node l,node r)&#123; now.lt_rt =(l.lt_rt &amp; now.t_m &amp; r.lt_rt) | (l.lt_rb &amp; now.b_m &amp; r.lb_rt); now.lt_rb =(l.lt_rt &amp; now.t_m &amp; r.lt_rb) | (l.lt_rb &amp; now.b_m &amp; r.lb_rb); now.lb_rt =(l.lb_rt &amp; now.t_m &amp; r.lt_rt) | (l.lb_rb &amp; now.b_m &amp; r.lb_rt); now.lb_rb =(l.lb_rt &amp; now.t_m &amp; r.lt_rb) | (l.lb_rb &amp; now.b_m &amp; r.lb_rb); now.lt_lb =l.lt_lb | (l.lt_rt &amp; now.t_m &amp; r.lt_lb &amp; now.b_m &amp; l.lb_rb); now.rt_rb =r.rt_rb | (r.lt_rt &amp; now.t_m &amp; l.rt_rb &amp; now.b_m &amp; r.lb_rb);&#125;void build(int l,int r,int rt)&#123; if(l==r)&#123; tree[rt].lt_rt=tree[rt].lb_rb=1; tree[rt].t_m=tree[rt].b_m=1; return; &#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1);&#125;void update1(int c,int r,int val,int L,int R,int rt)&#123; int m = (L+R) &gt;&gt; 1; if(m==c)&#123; if(r==1) tree[rt].t_m=val; if(r==2) tree[rt].b_m=val; pushup(tree[rt],tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]); return; &#125; if(c&lt;=m)update1(c,r,val,L,m,rt&lt;&lt;1); else update1(c,r,val,m+1,R,rt&lt;&lt;1|1); pushup(tree[rt],tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]);&#125;void update2(int c,int val,int l,int r,int rt)&#123; if(l==r)&#123; tree[rt].lt_rb=tree[rt].lt_lb=tree[rt].rt_rb=tree[rt].lb_rt=val; return; &#125; int m = (l+r) &gt;&gt; 1; if(c&lt;=m)update2(c,val,l,m,rt&lt;&lt;1); else update2(c,val,m+1,r,rt&lt;&lt;1|1); pushup(tree[rt],tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]);&#125;node query(int c1,int c2,int l,int r,int rt)&#123; int m = (l+r) &gt;&gt; 1; if(c1&lt;=l&amp;&amp;c2&gt;=r) return tree[rt]; if(c2 &lt;= m) return query(c1,c2,l,m,rt&lt;&lt;1); else if(c1 &gt;= m+1) return query(c1,c2,m+1,r,rt&lt;&lt;1|1); else&#123; node res = tree[rt]; pushup(res,query(c1,c2,l,m,rt&lt;&lt;1),query(c1,c2,m+1,r,rt&lt;&lt;1|1)); return res; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;N); build(1,N,1); char op[10]; while(scanf(\"%s\",op))&#123; if(op[0]=='E') break; int c1,c2,r1,r2,val; scanf(\"%d%d%d%d\",&amp;r1,&amp;c1,&amp;r2,&amp;c2); if(c1&gt;c2) swap(c1,c2),swap(r1,r2); if(op[0] == 'A')&#123; node n1=query(1,c1,1,N,1),n2=query(c1,c2,1,N,1),n3=query(c2,N,1,N,1); bool ans; if(r1==1 &amp;&amp; r2==1) ans = n2.lt_rt | (n1.rt_rb &amp; n2.lb_rt) | (n3.lt_lb &amp; n2.lt_rb) | (n3.lt_lb &amp; n1.rt_rb &amp; n2.lb_rb); if(r1==1 &amp;&amp; r2==2) ans = n2.lt_rb | (n1.rt_rb &amp; n2.lb_rb) | (n3.lt_lb &amp; n2.lt_rt) | (n3.lt_lb &amp; n1.rt_rb &amp; n2.lb_rt); if(r1==2 &amp;&amp; r2==1) ans = n2.lb_rt | (n1.rt_rb &amp; n2.lt_rt) | (n3.lt_lb &amp; n2.lb_rb) | (n3.lt_lb &amp; n1.rt_rb &amp; n2.lt_rb); if(r1==2 &amp;&amp; r2==2) ans = n2.lb_rb | (n1.rt_rb &amp; n2.lt_rb) | (n3.lt_lb &amp; n2.lb_rt) | (n3.lt_lb &amp; n1.rt_rb &amp; n2.lt_rt); puts(ans?\"Y\":\"N\"); &#125; else&#123; val = (op[0]=='O'?1:0); if(c1==c2) update2(c1,val,1,N,1); else update1(c1,r1,val,1,N,1); &#125; &#125;&#125; 区间加法好了今天的题就到这里了，最后说一下区间加法。什么是区间加法呢？简单来说，把一个大的区间分割成两个小的区间，如果能从小区间的统计量推算出大区间的统计量，那么这个统计量就是符合区间加法的。比如在今天的H题中，显然可以从小区间的颜色种类推出大区间的颜色种类，当然也有更复杂也更神奇一些的，比如在I题中，从小区间的联通性可以推知大区间的联通性，再比如说实际上gcd也是符合区间加法的，诸如此类的还有很多，都可以用线段树来进行维护。在线段树的代码中，有一个叫做pushup的函数，实际上这个函数就是用子区间做区间加法来更新母区间，尽管平时我们只用它来自下而上地更新线段树，但如果区间加法的过程较为复杂，我们也可以用这个函数来做区间加法，就像I题中那样。","tags":[{"name":"线段树","slug":"线段树","permalink":"https://lotusir.github.io/tags/线段树/"}]},{"title":"暑期集训第一周","date":"2019-07-29T05:24:14.000Z","path":"2019/07/29/Train1st/","text":"前言暑期集训开始了呢！一点都不兴奋呢！好吧不扯淡了，第一周学了STL、动态规划、搜索、数论等相关内容。 STL讲道理STL、C++的训练题真是一点意思也没有，全是模拟，没什么特别的题，先贴一个或许会用的到的函数吧（貌似以前就说过但不怎么用。。）。lower_bound(a,a+N,ask)函数,找到在a~a[N-1]范围内第一个比ask大的元素（可能是数字也可能是字符串、字符等）。返回一个指针，将这个指针减去a可以得到下标，由于是用二分实现，复杂度为log(n)。然后的话队列套队列挺有意思的（也可以各种STL嵌套），就贴这道题吧。 UVA-540VJ地址：UVA540题意简述：有若干个人排队，每个人有一个所属的队伍，当一个新来的人进入队列时，如果有队友在队列中，则插入最后一个队友的后面，否则排到队尾。ENQUEUE x代表x号进入队伍，DEQUEUE代表队列第一人出队，对于每一次DEQUEUE输出出队的人的编号，STOP停止模拟。解题：模拟就完事了，维护一个队伍的队列和队伍内的队列。AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;const int maxn = 1e3+200;using namespace std;queue&lt;int&gt; teamqueue;queue&lt;int&gt; manqueue[maxn];map&lt;int,int&gt; Team;bool inqueue[maxn];int t,a,n,kase;string op;int main()&#123; while(cin &gt;&gt; t)&#123; if(t==0) break; cout &lt;&lt; \"Scenario #\" &lt;&lt; ++kase &lt;&lt; endl; for(int i = 1; i &lt;= t; ++i)&#123; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a; Team[a]=i; &#125; &#125; while(cin &gt;&gt; op)&#123; if(op==\"STOP\") break; if(op==\"ENQUEUE\")&#123; cin &gt;&gt; a; if(inqueue[Team[a]]) manqueue[Team[a]].push(a); else&#123; manqueue[Team[a]].push(a); teamqueue.push(Team[a]); inqueue[Team[a]]=true; &#125; &#125; if(op==\"DEQUEUE\")&#123; int teamid=teamqueue.front(); int manid=manqueue[teamid].front(); manqueue[teamid].pop(); if(manqueue[teamid].empty())&#123; teamqueue.pop(); inqueue[teamid]=false; &#125; cout &lt;&lt; manid &lt;&lt; endl; &#125; &#125; cout &lt;&lt; endl; for(int i = 1; i &lt;= t; ++i) while(!manqueue[i].empty()) manqueue[i].pop(); while(!teamqueue.empty()) teamqueue.pop(); memset(inqueue,0,sizeof(inqueue)); &#125; return 0;&#125; 其实也挺无聊的。。而且UVA的格式要求真的是有毒。。 贪心贪心算法怎么说呢。。反正我不太擅长，可能我不够贪吧。。直接上题了。 POJ1700-Crossing RiverVJ地址：POJ1700题意简述：经典的过河问题。有N个人和1条船，第i个人过河需要的时间为ai，船能载两个人，船过河的时间是两个人中较慢的那个人的时间，问把所有人运过河至少需要多少时间。解题：想着让最快的人不停带人过去再回来，然后发现是错的。。因为还有另一种策略，最快的和第二快的一起过去，然后最快的回来，接着最慢的和第二慢的过去，b回来。这两种策略中选择一个较快的就是答案，此外当人数小于等于3时直接处理即可。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string&gt;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 1500;using namespace std;int T,N,a[maxn],ans;int main()&#123; cin &gt;&gt; T; while(T--)&#123; ans=0; cin &gt;&gt; N; for(int i = 0; i &lt; N; ++i) cin &gt;&gt; a[i]; sort(a,a+N); if(N &lt;= 3)&#123; if(N==1) ans = a[0]; if(N==2) ans = a[1]; if(N==3) ans = a[0]+a[1]+a[2]; &#125; else&#123; for(int i = N-1; i &gt; 1; i-=2)&#123; if(i &gt;= 3)&#123; if(a[0]+a[i-1]&gt;=2*a[1]) ans+=a[1]+a[0]+a[i]+a[1]; else ans+=a[i]+a[0]+a[i-1]+a[0]; &#125; else ans += a[2] + a[0]; &#125; ans += a[1]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; POJ3253-Fence RepaierVJ地址：POJ3253题意：哈夫曼树经典例题。AC代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 5e4+500;using namespace std;ll n,input,sum,ans;int main()&#123; priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; pq; cin &gt;&gt; n; for(ll i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; input; pq.push(input); &#125; while(pq.size()&gt;1)&#123; ll min1 = pq.top(); pq.pop(); ll min2 = pq.top(); pq.pop(); ans += min1+min2; pq.push(min1+min2); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 剩下几道比较简单或者不会，不想补了（咸鱼） 搜索搜索比较简单，暴力就完事了，贴两道状压搜索。 HDU1429-胜利大逃亡VJ地址：HDU1429题意：捡钥匙走迷宫，问能否在指定时间走出迷宫。解题：在BFS的基础上用一个int来存储角色获得的钥匙的状态，然后进行朴素的BFS即可。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int zt=0b111111111111;const int maxn = 22;const int dir[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;struct node&#123; int x,y,dep,key; node(int a,int b,int c,int d):x(a),y(b),dep(c),key(d)&#123;&#125;&#125;;char mp[maxn][maxn];int stx,sty,ans,dep[maxn][maxn][zt],n,m,t;void solve()&#123; memset(dep,-1,sizeof(dep)); ans = -1; queue&lt;node&gt; q; dep[stx][sty][0]=0; q.push(node(stx,sty,0,0)); while(!q.empty())&#123; node u = q.front(); q.pop(); int nkey=u.key; if(u.dep&gt;=t) break; if(mp[u.x][u.y]=='^')&#123; ans=u.dep; break; &#125; if(mp[u.x][u.y] &gt;= 'a' &amp;&amp; mp[u.x][u.y] &lt;= 'j') nkey |= (1 &lt;&lt; (mp[u.x][u.y]-'a')); for(int i = 0; i &lt; 4; ++i)&#123; int nx=u.x+dir[i][0],ny=u.y+dir[i][1]; if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) continue; if(mp[nx][ny]=='*') continue; if(mp[nx][ny]=='.' || mp[nx][ny]=='@' || (mp[nx][ny] &gt;= 'a' &amp;&amp; mp[nx][ny] &lt;= 'j') || mp[nx][ny] == '^') if(dep[nx][ny][nkey]==-1)&#123; dep[nx][ny][nkey]=u.dep+1; q.push(node(nx,ny,u.dep+1,nkey)); &#125; if(mp[nx][ny]&gt;='A'&amp;&amp;mp[nx][ny]&lt;='J') if(nkey &amp; (1 &lt;&lt; mp[nx][ny]-'A')) if(dep[nx][ny][nkey]==-1)&#123; dep[nx][ny][nkey]=u.dep+1; q.push(node(nx,ny,u.dep+1,nkey)); &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; t)&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; cin &gt;&gt; mp[i][j]; if(mp[i][j]=='@')&#123; stx=i; sty=j; &#125; &#125; solve(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 代码可能丑了点，不过难得搜索题一发AC！ CF||SHU||牛客-CSL的校园卡VJ地址：CSL的校园卡解题：不仅加入了一个状态记录走过的路径，而且有两个点，于是VIS[x][y]变成了vis[path][x1][y1][x2][y2]。接着进行BFS就行了。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 0b1111111111111111;const int inf = 0x3f3f3f3f;int n,m,tar,vis[maxn][5][5][5][5],mp[5][5],stx,sty,ans;int dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;char input;struct node&#123; int x1,y1; int x2,y2; int now; int dep; node(int a=0,int b=0,int c=0,int d=0,int e=0,int f=0):x1(a),y1(b),x2(c),y2(d),now(e),dep(f)&#123;&#125;&#125;;bool legal(int x,int y)&#123; if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;mp[x][y]==1) return true; else return false;&#125;void BFS()&#123; queue&lt;node&gt; q; q.push(node(stx,sty,stx,sty,1&lt;&lt;(stx*m+sty),0)); vis[1&lt;&lt;(stx*m+sty)][stx][sty][stx][sty]=1; while(!q.empty())&#123; int x1,y1,x2,y2,now,dep; x1=q.front().x1; y1=q.front().y1; x2=q.front().x2; y2=q.front().y2; now=q.front().now; dep=q.front().dep; q.pop(); //cout &lt;&lt; x1 &lt;&lt; \" \" &lt;&lt; y1 &lt;&lt; \" \" &lt;&lt; x2 &lt;&lt; \" \" &lt;&lt; y2 &lt;&lt; \" \" &lt;&lt; now &lt;&lt; \" \" &lt;&lt; dep &lt;&lt; \" \" &lt;&lt; tar &lt;&lt; endl; if(now==tar)&#123; ans=dep; break; &#125; for(int i = 0; i &lt; 4; i++)&#123; int newx1,newy1,tmp; newx1=x1+dir[i][0];newy1=y1+dir[i][1]; if(!legal(newx1,newy1)) continue; for(int j = 0; j &lt; 4; j++)&#123; int newx2,newy2; newx2=x2+dir[j][0];newy2=y2+dir[j][1]; if(legal(newx2,newy2)) tmp = now | (1&lt;&lt;(newx2*m+newy2)) | (1&lt;&lt;(newx1*m+newy1)); else continue; if(!vis[tmp][newx1][newy1][newx2][newy2])&#123; vis[tmp][newx1][newy1][newx2][newy2]=1; q.push(node(newx1,newy1,newx2,newy2,tmp,dep+1)); &#125; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j)&#123; cin &gt;&gt; input; if(input == 'X') mp[i][j]=0; else&#123; mp[i][j]=1; tar |= (1&lt;&lt;(i*m+j)); &#125; if(input == 'S')&#123; stx=i; sty=j; &#125; &#125; BFS(); cout &lt;&lt; ans;&#125; 倒也不难，但没接触过状压搜索的话估计想不到。 搜索就这样了，反正就是各种暴力。 动态规划DP。。。DP咋办呢，我实在时不会啊emmmm LCS（最长公共子序列）VJ地址：HDU1159题意：LCS裸题，经典DP应用，直接上代码了。AC代码： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;const int maxn = 200;using namespace std;string s1,s2;int lcs(string s1, string s2) &#123; int len1 = s1.size(); int len2 = s2.size(); vector&lt;vector&lt;int&gt;&gt; c(len1+1, vector&lt;int&gt;(len2+1, 0)); for (int i = 1 ; i &lt;= len1; i++) &#123; for(int j = 1; j &lt;=len2 ; j++) &#123; if (s1[i-1] == s2[j-1]) c[i][j] = c[i - 1][j - 1] + 1; else if (c[i - 1][j] &gt;= c[i][j - 1]) c[i][j] = c[i - 1][j]; else c[i][j] = c[i][j - 1]; &#125; &#125; return c[len1][len2];&#125;int main()&#123; while(cin &gt;&gt; s1 &gt;&gt; s2)&#123; cout &lt;&lt; lcs(s1,s2) &lt;&lt; endl; &#125; return 0;&#125; CF1105C-Ayoub and Lost ArrayVJ地址：CF1105C题意：给定l,r,n，求在[l,r]内选n个数(可以重复选)，要求这些数的和能被3整除，有几种选法。解题：求出[l,r]范围内被3除余0,1,2的数的个数，从小到大更新dp。dp[i][j]表示选i个数，余数为j的方案数。显然dp[0][0]=0,且有：dp[i+1][0]=dp[i][0]*MOD[0]+dp[i][1]*MOD[2]+dp[i][2]*MOD[1]以此类推，注意取模，最后输出dp[n][0]就是答案，另外统计[l,r]内被3除余数不同的数的个数时不能暴力。。AC代码： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;const int maxn = 2e5+100;const int mod = 1e9+7;using namespace std;long long n,l,r,MOD[3],dp[maxn][3];int main()&#123; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; for(int i = 0; i &lt; 3; ++i) MOD[i]=(r-l+1)/3; for(int i = 0; i &lt; (r-l+1)%3; ++i)&#123; if((l+i)%3==0)MOD[0]++; if((l+i)%3==1)MOD[1]++; if((l+i)%3==2)MOD[2]++; &#125; dp[0][0]=1; for(int i = 1; i &lt;= n; ++i)&#123; dp[i][0] = (dp[i-1][0]*MOD[0]%mod+dp[i-1][1]*MOD[2]%mod+dp[i-1][2]*MOD[1]%mod)%mod; dp[i][1] = (dp[i-1][0]*MOD[1]%mod+dp[i-1][1]*MOD[0]%mod+dp[i-1][2]*MOD[2]%mod)%mod; dp[i][2] = (dp[i-1][0]*MOD[2]%mod+dp[i-1][1]*MOD[1]%mod+dp[i-1][2]*MOD[0]%mod)%mod; &#125; cout &lt;&lt; dp[n][0] &lt;&lt; endl; return 0;&#125; CF1096D-Easy ProblemVJ地址:CF1096D题意：给一个字符串，删去若干个字符，删去每个字符的cost不同，问让这个字符串不含”hard”子序列至少需要多少cost。解题：对于’h’，只能删去所有的’h’，对于’a’，可以删去所有’h’或所有’a’或所有符合顺序的’ha’，以此类推。AC代码： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;const int maxn = 1e5+100;using namespace std;int n;int val[maxn];string s;long long ans,h,a,r,d;int main()&#123; cin &gt;&gt; n; cin &gt;&gt; s; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; val[i]; for(int i = 0; i &lt; n; ++i)&#123; if(s[i]=='h') h+=val[i]; if(s[i]=='a') a=min(h,a+val[i]); if(s[i]=='r') r=min(a,r+val[i]); if(s[i]=='d') d=min(r,d+val[i]); &#125; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; h,a,r,d分别记录到i位置对于该字母的最优策略，显然后面的字母的最优策略会优于前面的或者等于前面的，其实就是一个dp[4][n]被压缩到1维的结果; HDU1024-Max Sum Plus Plusvj地址：HDU1024题意：自己看吧。。解题：挺神奇的，把2维的dp压缩的过程。（还没很弄懂，以后再回来看看吧）AC代码： 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;const int maxn = 1e6+100;const int mod = 1e9+7;const long long inf = 0x3f3f3f3f;using namespace std;int m,n;long long dp[maxn],a[maxn],pre[maxn],mx;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(); while(cin &gt;&gt; m &gt;&gt; n)&#123; memset(dp,0,sizeof(dp)); memset(pre,0,sizeof(pre)); for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= m; ++i)&#123; mx = -inf; for(int j = i; j &lt;= n; ++j)&#123; dp[j]=max(dp[j-1],pre[j-1])+a[j]; pre[j-1]=mx; mx=max(mx,dp[j]); &#125; &#125; cout &lt;&lt; mx &lt;&lt; endl; &#125; return 0;&#125; 做了一天的DP感觉自己的DP还是很菜。。 数论今天累了明天吧。 - 2019/7/29","tags":[{"name":"-STL -动态规划 -搜索 -数论 -贪心","slug":"STL-动态规划-搜索-数论-贪心","permalink":"https://lotusir.github.io/tags/STL-动态规划-搜索-数论-贪心/"}]},{"title":"HDU09","date":"2019-07-08T11:38:08.000Z","path":"2019/07/08/HDU09/","text":"比赛地址：HDU09做了四道。。还行吧。 HDU09A Big binary tree待补 B Ch’s gift题意：给一棵树，点有点权，给两个点，给最小值和最大值，求两点间的路径上点权在[最小值，最大值]范围内的点权之和。解题：树链剖分？还没学，明天看情况补吧。 C CSGO计算几何？大陀螺，待补。 D Dying Light看着像计算几何，待补。 FFF at Valentine题意：给一张有向图，问存不存在两点互不联通。解题：方法一：暴力万岁！对每个点进行BFS判断联通即可。AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;const int maxn = 1100;using namespace std;int T,m,n,able[maxn][maxn],vis[maxn];vector&lt;int&gt; E[maxn];void BFS(int pos)&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(pos); while(!q.empty())&#123; int t = q.front(); q.pop(); if(vis[t]) continue; vis[t]=1; able[pos][t] = 1; for(int i = 0; i &lt; E[t].size(); ++i) if(!vis[E[t][i]]) q.push(E[t][i]); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d%d\",&amp;n,&amp;m); while(m--)&#123; int f,t; scanf(\"%d%d\",&amp;f,&amp;t); E[f].push_back(t); &#125; for(int i = 1; i &lt;= n; ++i) BFS(i); bool flag = true; for(int i = 1; i &lt;= n &amp;&amp; flag; ++i)&#123; for(int j = 1; j &lt;= n &amp;&amp; flag; ++j)&#123; if(!able[i][j] &amp;&amp; !able[j][i]) flag = false; &#125; &#125; if(!flag) puts(\"Light my fire!\"); else puts(\"I love you my love and our love save us!\"); for(int i = 1; i &lt;= n; ++i) E[i].clear(); memset(able,0,sizeof(able)); &#125; return 0;&#125; 时间卡的比较紧。。还好数据不强。 方法二：tarjan+拓扑排序=我不会代码：CSDN博客 Senior Pan题意：给一张有向图，给一个点集，求点集中最短路的最小值。解题：方法一：构造一个超级源点，连接所有点集中的点且边权为0。超级源点到点集中点的最短路的最小值就是点集中最短路的最小值，跑一次dij就好了。注意最小值可能是一个点到自己的距离，要把这种情况排除。 tips:添加超级源点可以通过把所有与超级源点相连的点push进queue实现，不必真的添加源点。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;const int maxn = 100000+400;const int inf = 0x3f3f3f3f;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; int from; nod(int a = 0,int b = 0,int c = 0)&#123;pos=a;d=b;from=c;&#125; friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;vector&lt;edge&gt; E[maxn];vector&lt;int&gt; beg;int T,n,m,k,dis[maxn],mndis = inf,vis[maxn];void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); return;&#125;void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; for(int i = 0; i &lt; beg.size(); ++i) Q.push(nod(beg[i],0,beg[i])); while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; int from = temp.from; Q.pop(); if(d &gt; dis[pos]) continue; for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; if(vis[to] &amp;&amp; to != from) mndis = min(mndis,nd); if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd,vis[to]?to:from)); &#125; &#125; &#125;&#125;void reset()&#123; beg.clear(); for(int i = 1; i &lt;= n; ++i) E[i].clear(); mndis = inf; memset(vis,0,sizeof(vis));&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; while(m--)&#123; int from,to,val; cin &gt;&gt; from &gt;&gt; to &gt;&gt; val; add(from,to,val); &#125; cin &gt;&gt; k; while(k--)&#123; int x; cin &gt;&gt; x; beg.push_back(x); vis[x]=1; &#125; dij(); cout &lt;&lt; \"Case #\" &lt;&lt; ++kase &lt;&lt; \": \" &lt;&lt; mndis &lt;&lt; endl; reset(); &#125; return 0;&#125; 方法二：最短路+随机=我又不会代码：CSDN博客 G Missile Interception待补 H Numbers题意：给两个数列a和数列b，数列b中的每一个数的值是数列a中两个数的和。如a为1，2，3，那么b为1+2，1+3，2+3也就是3，4，5。解题：前两个数一定是a中的数，他们的和一定是b中的一个数，向后循环，每在a中加入一个数从数列中删去所有这个数能产生的和。用map维护。总之就是暴力模拟。。AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 125251;const int INF = 0x3f3f3f3f;int str[maxn];int m,n;vector&lt;int&gt; a;map&lt;int,int&gt; b; //记录first在b中出现的次数int main()&#123; while(scanf(\"%d\",&amp;m)!=EOF) &#123; n = (-1 + sqrt(1 + 8 * m)) / 2; for(int i=0;i&lt;m;i++) scanf(\"%d\",&amp;str[i]); sort(str,str+m); a.clear(); b.clear(); a.push_back(str[0]); a.push_back(str[1]); b[a[0] + a[1]]++; for(int i=2;i&lt;m;i++) &#123; if(b[str[i]]) &#123; b[str[i]]--; continue; &#125; else &#123; a.push_back(str[i]); for(int j=0;j&lt;a.size()-1;j++) &#123; int sum = a[j] + str[i]; b[sum]++; &#125; &#125; &#125; printf(\"%d\\n\",n); for(int i=0;i&lt;n-1;i++) &#123; printf(\"%d \",a[i]); &#125; printf(\"%d\\n\",a[n-1]); &#125;&#125; I Senior PanⅡ待补。 J Two strings字符串匹配，dp，队友太猛了。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2500 + 10;char a[maxn],b[maxn];int dp[maxn][maxn];int main()&#123; int T;scanf(\"%d\",&amp;T); while(T --) &#123; scanf(\"%s%s\",a+1,b+1); int la = strlen(a+1),lb = strlen(b+1); bool flag = true; int j = 1;memset(dp,0,sizeof(dp)); dp[0][0] = 1; for(int i = 1; i &lt;= la; i ++) &#123; for(int j = 1; j &lt;= lb; j ++) &#123; if(a[i] == b[j]) &#123; if( (b[j + 1] == '*' &amp;&amp; dp[i][j - 1]) || dp[i - 1][j - 1] == 1)dp[i][j] = 1; if(b[j - 1] == '*' &amp;&amp; ( dp[i - 1][j - 3] || dp[i][j - 1]) )dp[i][j] = 1; &#125; else if(b[j] == '.') &#123; if(dp[i - 1][j - 1])dp[i][j] = 1; &#125; else if(b[j] == '*') &#123; if(a[i - 1] == a[i] &amp;&amp; (dp[i - 1][j] || dp[i - 1][j - 1]) )dp[i][j] = 1; if(b[j - 1] == '.' &amp;&amp; dp[i - 1][j - 1] &amp;&amp; a[i] == a[i - 1])dp[i][j] = 1; if(dp[i][j - 2] || dp[i][j - 1] )dp[i][j] = 1; &#125; else dp[i][j] = 0; &#125; &#125; if(dp[la][lb]) printf(\"yes\\n\"); else printf(\"no\\n\"); &#125; return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"暴力","slug":"暴力","permalink":"https://lotusir.github.io/tags/暴力/"}]},{"title":"ACM暑期训练赛（HDU08）","date":"2019-07-04T09:22:32.000Z","path":"2019/07/04/HDU08/","text":"2019/7/4 真TM热今天的比赛是英语阅读专场。 比赛地址：HDU08由于是英语阅读专场（星战粉专场）只给做出来的题的题意和题解了。。真的不想翻译有多阅读专场？建议阅读H题。 HDU08A Army Formations数据结构题，不会。 B Battlestation Operational没看，天澜大佬做出来了，不知道有多难。 C Casual Podracing没看，不翻译了。 D Death Podracing没看。 E Engineering of the Clones没看。 F Fleet of the Eternal Throne题意：有点难解释，自己看吧。。解题：杭电真喜欢AC自动机把给出的模式串构造AC自动机，AC自动机的节点记录当前字符串的长度，对于给出的X和Y，先把字符串X在AC自动机上跑一遍，记录所有匹配到的节点（包括fail节点，不一定是字符串的结束节点），这些匹配到的节点既是某个模式串的前缀，又是X的子串。再把字符串Y在AC自动机上跑一遍，匹配到已经被标记过的节点时更新最长长度，最后输出即可。这题的输入有点坑，模式串一共1e5行，但模式串的总长又不超过1e5，写输入写了好久。。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;const int maxn = 1e5 + 500;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; trie *fail; int len; bool flag; trie() &#123; len = 0; flag = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int T,n,m,x,y,pos[maxn];char S[maxn],s1[maxn],s2[maxn];void Insert(char *s)&#123; trie *p = root; int len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; if(p-&gt;nxt[id] != NULL) &#123; p -&gt; nxt[id] -&gt; len = p -&gt; len + 1; p = p-&gt;nxt[id]; &#125; else &#123; p -&gt; nxt[id] = new trie; p -&gt; nxt[id] -&gt; len = p -&gt; len + 1; p = p -&gt; nxt[id]; &#125; &#125;&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty()) &#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i) &#123; if(p -&gt; nxt[i]) &#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else &#123; temp = p -&gt; fail; while(temp) &#123; if(temp -&gt; nxt[i]) &#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;void queryx(char* s)&#123; int i = 0; trie *p = root; trie *temp; while(s[i]) &#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root) &#123; temp -&gt; flag = 1; temp = temp -&gt; fail; &#125; i++; &#125; return;&#125;int queryy(char* s)&#123; int i = 0,mxlen = 0; trie *p = root; trie *temp; while(s[i]) &#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root) &#123; if(temp -&gt; flag == 1) mxlen = max(mxlen,temp-&gt;len); temp = temp -&gt; fail; &#125; i++; &#125; return mxlen;&#125;void Free(trie *p)&#123; for(int i = 0; i &lt; 26; ++i) &#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;void reset(trie *p)&#123; for(int i = 0; i &lt; 26; ++i) &#123; if(p -&gt; nxt[i] != NULL) reset(p-&gt;nxt[i]); &#125; p -&gt; flag = 0;&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; root = new trie; scanf(\"%d\",&amp;n); int d = 0; getchar(); for(int i = 1; i &lt;= n; ++i)&#123; gets(S+d); Insert(S+d); pos[i] = d; d += strlen(S+d) + 1; &#125; getFail(); scanf(\"%d\",&amp;m); while(m--)&#123; reset(root); scanf(\"%d%d\",&amp;x,&amp;y); queryx(S+pos[x]); printf(\"%d\\n\",queryy(S+pos[y])); &#125; Free(root); &#125;&#125; G Galaxy at War没看 H Hybrid Crystals题意：给出数组a1,a2,a3….an，同时给出字符数组b1,b2,b3….bn,如果bi是N，那么ai可正可负，如果bi是L，那么ai是正的，如果bi是D，那么ai是负的，给出一个整数k，询问能否从ai中取出若干个使它们的和为k。此外还有一个奇怪的不等式$ai≤∑j=1i−1aj[bj=N]+∑j=1i−1aj[bi=L∩bj=L]+∑j=1i−1aj[bi=D∩bj=D]( 2 ≤ i ≤ n ).$解题：这个不等式保证了相邻的ai至多只会差1，初始状态下只有a1可以构成[-1,1]间所有的整数，此时如果来了一个正数1，那么能构成的值变成了[0,1]，如果来了一个负数1，那么能构成[-2,0]，若是正负1,那么能构成[-2,2]，区间的扩展是连续的，例如对于a1，只有出现一个3才会打断区间的连续性变成[2,4]，也就是只有当ai+1=ai+2时才会打断连续性，而不等式保证了不会出现这种情况。换句话说，每一个数都只会连续地扩大能够得到的和的范围，因此只要统计出最大负值和最大正值再判断k是否在这个区间呢就可以了。AC代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;const int maxn = 1e3+200;using namespace std;int T,n,k,a[maxn],psum,nsum;char in;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; psum = 0;nsum = 0; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a[i]; &#125; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; in; if(in == 'L') psum+=a[i]; else if(in == 'D') nsum+=a[i]; else&#123;psum+=a[i];nsum+=a[i];&#125; &#125; if(k &gt; 0)&#123; if(k &lt;= psum) puts(\"yes\"); else puts(\"no\"); &#125; else&#123; if(-k &lt;= nsum) puts(\"yes\"); else puts(\"no\"); &#125; &#125; return 0;&#125; I I am your Father!没看。 J Jedi Council没看。 K Killer Names题意：给出两个整数n和m，要求在大小为m的字符集中选出若干个字符，组成两段长度为n的字符串，要求两串字符串中不能有相同的字符（如在第一个字符串中出现了’a’，那么第二个字符串中就不能再出现’a’，但同一个字符串内可以有重复的字符）。题解：排列组合题，学到了新的东西——第二类斯特林数，第二类斯特林数是将m个格子分成n个集合有多少种不同的分法，我准备单独写一篇排列组合的文章了。。AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;typedef long long ll;const ll mod = 1e9+7;using namespace std;ll T,n,m,fac[3000],c[3000][3000],s[3000][3000];ll qpow(ll a,ll b)&#123; ll res=1; while(b)&#123; if(b&amp;1) res = res * a % mod; b &gt;&gt;= 1; a = a * a % mod; &#125; return res;&#125;void init()&#123; //阶乘 fac[0]=fac[1]=1; for(int i = 2; i &lt;= 2000; ++i) fac[i] = fac[i-1] * i % mod; //组合数（杨辉三角） for(int i=0;i&lt;=2000;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(j==0 || j==i) c[i][j]=1; else c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod; &#125; &#125; //斯特林数 for(int i=0;i&lt;=2000;i++) s[i][i]=1,s[i][0]=0; for(int i=1;i&lt;=2000;i++) &#123; for(int j=1;j&lt;=i-1;j++) &#123; s[i][j]=(j*s[i-1][j]+s[i-1][j-1])%mod; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); init(); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; ll ans=0; for(ll i = 1; i &lt;= m - 1; ++i)&#123; ll tmp = c[m][i] * s[n][i] % mod * fac[i] % mod; for(ll j = 1; j &lt;= m - i; ++j)&#123; ans = ans + tmp * c[m-i][j] % mod * s[n][j] % mod * fac[j] % mod; ans %= mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 后记题面实在太长了，连补的欲望都没有了。。","tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://lotusir.github.io/tags/AC自动机/"},{"name":"排列组合","slug":"排列组合","permalink":"https://lotusir.github.io/tags/排列组合/"},{"name":"思维","slug":"思维","permalink":"https://lotusir.github.io/tags/思维/"}]},{"title":"线段树的区间修改","date":"2019-07-04T07:13:14.000Z","path":"2019/07/04/SegmentChange/","text":"又是线段树相关的内容！这次的文章会介绍线段树的区间修改（包括加减和改值） 在开始区间修改的介绍前，如果你对线段树没有任何了解，请移步线段树基础。 懒惰标记区间修改用到了一个很巧妙的思想——懒惰标记。在某个节点上的懒惰标记，就是它的子节点需要做出的变化，为节点加上懒惰标记后，不需要急于将标记下传，当以后的查询过程或修改过程遍历到它是再进行下传。于是线段树的结构体中又多了一个lazy变量，当然也可以用lazy数组实现。本文代码为求和线段树 下传函数将懒惰标记下传的函数，在修改、查询等过程中用到，记得下传后消除自己的懒惰标记。比较简单，自己理解。 1234567891011121314151617181920void pushdown(int l,int r,int rt)&#123; //区间改值 if(lazy[rt])&#123; int m = (l+r) &gt;&gt; 1; lazy[rt&lt;&lt;1] = lazy[rt]; lazy[rt&lt;&lt;1|1] = lazy[rt]; Sum[rt&lt;&lt;1] = lazy[rt] * (m-l+1); Sum[rt&lt;&lt;1|1] = lazy[rt] * (r-m); lazy[rt] = 0; &#125; //区间增减 /*if(lazy[rt])&#123; int m = (l+r) &gt;&gt; 1; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; Sum[rt&lt;&lt;1] += lazy[rt] * (m-l+1); Sum[rt&lt;&lt;1|1] += lazy[rt] * (r-m); lazy[rt] = 0; &#125;*/&#125; 区间修改区间修改包含了改值和加减，它的过程与区间查询的过程类似，当要修改的区间完全包含某一节点，直接给该节点打上lazy标记，否则继续拆分。 123456789101112131415161718void segupdate(int L,int R,int l,int r,int rt,int lzy)&#123; if(L &lt;= l &amp;&amp; R &gt;= r)&#123; //区间改值 lazy[rt]=lzy; Sum[rt] = (r-l+1) * lzy; //区间加减 /*lazy[rt]+=lzy; sum[rt]+=(r-l+1) * lzy;*/ return; &#125; ll m = (l+r) &gt;&gt; 1; pushdown(l,r,rt); if(L &lt;= m) segupdate(L,R,l,m,rt&lt;&lt;1,lzy); if(R &gt; m) segupdate(L,R,m+1,r,rt&lt;&lt;1|1,lzy); pushup(rt); return;&#125; 完整模版线段树区间修改新增的东西到此结束，但是由于懒惰标记和下传函数的加入，单点修改和查询函数也要做出相应的修改（添加下传函数）。下面给出完整的模版（数组实现求和线段树），不含主函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define FAST ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)typedef long long ll;const int maxn = 2e5+300;const int inf = 0x3f3f3f3f;using namespace std;int a[maxn],Sum[maxn&lt;&lt;2],lazy[maxn];//更新当前节点void pushup(int rt)&#123; Sum[rt] = Sum[rt&lt;&lt;1] + Sum[rt&lt;&lt;1|1];&#125;//下传函数void pushdown(int l,int r,int rt)&#123; //区间改值 if(lazy[rt])&#123; int m = (l+r) &gt;&gt; 1; lazy[rt&lt;&lt;1] = lazy[rt]; lazy[rt&lt;&lt;1|1] = lazy[rt]; Sum[rt&lt;&lt;1] = lazy[rt] * (m-l+1); Sum[rt&lt;&lt;1|1] = lazy[rt] * (r-m); lazy[rt] = 0; &#125; //区间增减 /*if(lazy[rt])&#123; int m = (l+r) &gt;&gt; 1; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; Sum[rt&lt;&lt;1] += lazy[rt] * (m-l+1); Sum[rt&lt;&lt;1|1] += lazy[rt] * (r-m); lazy[rt] = 0; &#125;*/&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号void build(int l,int r,int rt)&#123; if(l == r)&#123; Sum[rt] = a[l]; return; &#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 [L,R]查询的区间int query(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return Sum[rt]; int m = (l+r) &gt;&gt; 1; int res = 0; pushdown(l,r,rt); if(L &lt;= m) res += query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) res += query(L,R,m+1,r,rt&lt;&lt;1|1); return res;&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 将L的值改为Vvoid update(int L,int V,int l,int r,int rt)&#123; if(l==r)&#123;Sum[rt]=V;return;&#125; int m = (l+r) &gt;&gt; 1; pushdown(l,r,rt); if(L &lt;= m) update(L,V,l,m,rt&lt;&lt;1); else update(L,V,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;void segupdate(int L,int R,int l,int r,int rt,int lzy)&#123; if(L &lt;= l &amp;&amp; R &gt;= r)&#123; //区间改值 lazy[rt]=lzy; Sum[rt] = (r-l+1) * lzy; //区间加减 /*lazy[rt]+=lzy; sum[rt]+=(r-l+1) * lzy;*/ return; &#125; int m = (l+r) &gt;&gt; 1; pushdown(l,r,rt); if(L &lt;= m) segupdate(L,R,l,m,rt&lt;&lt;1,lzy); if(R &gt; m) segupdate(L,R,m+1,r,rt&lt;&lt;1|1,lzy); pushup(rt); return;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lotusir.github.io/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://lotusir.github.io/tags/线段树/"}]},{"title":"HDU6096-String（AC自动机）","date":"2019-07-04T03:25:38.000Z","path":"2019/07/04/HDU6096/","text":"题目地址：HDU6096Problem DescriptionBob has a dictionary with N words in it.Now there is a list of words in which the middle part of the word has continuous letters disappeared. The middle part does not include the first and last character.We only know the prefix and suffix of each word, and the number of characters missing is uncertain, it could be 0. But the prefix and suffix of each word can not overlap.For each word in the list, Bob wants to determine which word is in the dictionary by prefix and suffix.There are probably many answers. You just have to figure out how many words may be the answer. InputThe first line of the input gives the number of test cases T; T test cases follow.Each test case contains two integer N and Q, The number of words in the dictionary, and the number of words in the list.Next N line, each line has a string Wi, represents the ith word in the dictionary (0&lt;|Wi|≤100000)Next Q line, each line has two string Pi , Si, represents the prefix and suffix of the ith word in the list (0&lt;|Pi|,|Si|≤100000,0&lt;|Pi|+|Si|≤100000)All of the above characters are lowercase letters.The dictionary does not contain the same words. LimitsT≤50&lt;N,Q≤100000∑Si+Pi≤500000∑Wi≤500000 OutputFor each test case, output Q lines, an integer per line, represents the answer to each word in the list. Sample Input14 4abacdeacdefacdefa acd efac ace f Sample Output2110 题意：给若干个字符串，进行若干次询问，每次询问给出一个前缀和后缀，问同时有这个前缀和后缀的字符串有几个，前缀与后缀不能重叠。解题：一道构造很巧妙的AC自动机题，首先存下给出的字符串，接着将给出的前缀(s1)和后缀(s2)以s2 + ‘{‘ + s1的形式插入字典树，构造AC自动机Fail指针，然后将每个字符串S转换成S + ‘{‘ + S的形式在AC自动机上跑，每经过一个结束节点就在这个节点的计数器上加一，不过要注意由于前缀和后缀不能重叠，因此s2+s1的长度不能超过S，最后按照询问的顺序输出结束节点的计数器即可。之所以用’{‘是因为它等于’a’+26容易建树，当然也可以用别的字符。以cd ef的查询为例，他被构造成了”ef{cd”插入了字典树，那么当用cdef{cdef跑AC自动机时就会找到这个子串。如果不用’{‘分割，那么ab cd就会匹配到aabcde，显然是不对的。最后是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;const int maxn = 1e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[27]; trie *fail; int len; int cnt; trie() &#123; len = 0; cnt = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root,*tr[maxn];int T,N,Q,tot;string S[maxn],s1,s2;void Insert(string s)&#123; trie *p = root; for(int i = 0; i &lt; s.length(); i++) &#123; int id = s[i]-'a'; if(p-&gt;nxt[id] != NULL) &#123; p = p-&gt;nxt[id]; &#125; else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; tr[tot++] = p; p -&gt; len = s.length();&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty()) &#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 27; ++i) &#123; if(p -&gt; nxt[i]) &#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else &#123; temp = p -&gt; fail; while(temp) &#123; if(temp -&gt; nxt[i]) &#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;void query(string s)&#123; trie *p = root; trie *temp; for(int i = 0; i &lt; s.length(); ++i)&#123; int id = s[i]-'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root) &#123; if(temp-&gt;len &lt;= (s.length()-1)/2+1) temp-&gt;cnt++; temp = temp -&gt; fail; &#125; &#125;&#125;void Free(trie *p)&#123; for(int i = 0; i &lt; 27; ++i) &#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; tot = 0; root = new trie; cin &gt;&gt; N &gt;&gt; Q; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; S[i]; S[i] = S[i] + '&#123;' + S[i]; &#125; while(Q--)&#123; cin &gt;&gt; s1 &gt;&gt; s2; Insert(s2+'&#123;'+s1); &#125; getFail(); for(int i = 0;i &lt; N; ++i) query(S[i]); for(int i = 0;i &lt; tot;i++) cout &lt;&lt; tr[i]-&gt;cnt&lt;&lt; endl; Free(root); &#125; return 0;&#125;","tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://lotusir.github.io/tags/AC自动机/"},{"name":"字符串","slug":"字符串","permalink":"https://lotusir.github.io/tags/字符串/"}]},{"title":"并查集","date":"2019-07-03T14:31:16.000Z","path":"2019/07/03/UnionFind/","text":"并查集并查集是一种数据结构，用于快速合并多个集合以及查询两个节点是否在同一个集合中。 引言思考一个简单的问题：有若干个点，每一次将其中两点连起来，若干次操作后，询问任意两点是否被联通。这样的问题要怎么解决呢？废话，当然就是要依靠本文下面将介绍的并查集的算法啦！ 思考问题对于这样的问题，显然我们可以直接将两点相连，但如果这么做，询问时就会遇到麻烦。DFS?BFS?当点的数目非常多时，这么做的复杂度似乎太高了。 并查集的作用顾名思义，并查集主要有两个作用，“并”和“查”。“并”，就是将两个集合合并到一起；“查”就是是查询两点是否在同一集合中。它的主要作用就是用来解决形如引言中那样的问题。并查集采用的是一种类树形结构，那么为什么要采用类树形结构呢？因为无论是合并还是查询，树形结构都很方便，也很快。大家知道，一棵k叉树的查询复杂度是O(logk(n))，除非k等于一，否则查询的速度是非常可观的。同时，要合并两棵树也非常容易——只要将两棵树的根直接相连就可以了。 并查集的结构体实现并查集既可以用结构体实现，也可以用数组实现，这里首先给出结构体的实现和讲解，文末给出数组实现，留给读者自己思抄考写。 节点的定义首先是并查集节点的定义，之所以说并查集是一种类树形结构，是因为它与树形结构有所不同，它的节点指针方向是与树相反的。树形结构的指针方向，由父节点指向子节点，而并查集节点的指针方向则由子节点指向父节点。（可以把并查集的这种数据结构看做一棵倒着的树）。所以，并查集的结构体非常简单，只需要一个指向父节点的指针以及原始数据即可。 123456struct node&#123; //数据 int id; //父节点 node *father = NULL;&#125; 路径压缩在开始具体代码的实现前，我们来理一理逻辑。要怎么合并两棵树？连接两棵树的根节点即可。要怎么连接两棵树的根节点呢？很简单，让某一个根节点的父亲指针指向另一个就行了，不过在这之前我们必须要先找到他们的根节点。因此下面会首先给出寻找根节点的代码实现，那么路径压缩又是什么呢？我们知道，一棵树的深度越浅，我们寻找根节点的效率也就越高，最优的情况下是怎样的呢？所有的节点都紧紧围绕着根节点就像全中国人民紧密团结在习主席周围。要单独进行这样的优化比较浪费时间，因此我们可以在寻根的过程中一并递归处理，当然这样并不能保证所有节点直接连接根节点，但已经足够紧密了。 并查集的寻根知道路径压缩以后，我们可以开始寻找根节点了。寻根过程很简单，一路沿着某一节点搜索父节点指针，直到没有父节点或者父节点是其自身（这两种情况是等价的，与代码实现有关）就可以了。那么路径压缩呢？只要将寻根过程碰到的所有节点的父指针直接指向根节点就可以了，这个操作可以用递归的方式简单实现。代码如下： 1234node* FindRoot(node *a)&#123; if(a-&gt;father == NULL) return a; else return a-&gt;father = FindRoot(a-&gt;father);&#125; 并查集的合并合并过程在之前就已经说过了，对于两个节点，如果根节点不同，将一个的根节点的父亲指针指向另一个根节点，如果相同，那么不需要进行合并操作。因为已经有了寻根的函数，合并的实现就变得非常简单，代码如下： 12345void Union(node *from,node *to)&#123; node *f1 = FindRoot(from),*f2 = FindRoot(to); if(f1 == f2) return; f2-&gt;father=f1;&#125; 例题及数组实现解释完并查集的结构体实现，那么又到了喜闻乐见的模版和例题环节了，模版中用数组实现了并查集。例题：HDU1232题意：给出若干个点和若干条边，询问要将整张图联通起来，至少还需要几条边。解题思路：这是一道模版题，时间很充裕，用并查集可以简单得出结果。步骤如下1.对于给出的每一条边，对边的两个端点进行“并”的操作。2.完成第1步后，整张图被分为了多个互相之间不连通的集合，要让整张图连通，需要的边数就是集合数减一。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;const int maxn = 1500;using namespace std;int N,M,father[maxn],a,b,vis[maxn],cnt;int Find(int a)&#123; if(father[a]==a) return a; return father[a]=Find(father[a]);&#125;void Union(int a,int b)&#123; int f1=Find(a),f2=Find(b); father[f2] = f1;&#125;void init()&#123; for(int i = 1; i &lt;= N; ++i) father[i]=i; memset(vis,0,sizeof(vis)); cnt=0;&#125;int main()&#123; //用于加速输入输出，忽视就行了 ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; N)&#123; if(N==0)break; cin &gt;&gt; M; init(); while(M--)&#123; cin &gt;&gt; a &gt;&gt; b; Union(a,b); &#125; for(int i = 1; i &lt;= N; ++i)&#123; int tmp = Find(i); if(!vis[tmp])&#123; cnt++; vis[tmp]=1; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl; &#125; return 0;&#125; 后记并查集的介绍到此结束，这是一种比较简单的数据结构，在Kruscal算法中会用到并查集的算法。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lotusir.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"https://lotusir.github.io/tags/并查集/"}]},{"title":"置顶","date":"2019-07-03T12:04:07.000Z","path":"2019/07/03/top/","text":"大佬队友的博客 SHU-SSYZE 模版地址：模版我又来更新这个没人看的博客了，加入ACM暑期菜鸡集训和神经网络（没有）相关的东西。 本博客已有的算法讲解和模版：1、AC自动机2、字典树3、线段树4、最短路5、最小生成树即将加入的算法讲解和模版：1、tarjan2、匈牙利算法3、km算法4、kmp算法","tags":[]},{"title":"线段树基础","date":"2019-07-02T14:54:23.000Z","path":"2019/07/02/SegmentTree/","text":"线段树线段树是一种树形数据结构，用于快速统计和修改区间上的统计量。 线段树能做什么？线段树是一种完全二叉树，建树的时间复杂度为O(nlogn)，查询以及修改的复杂度都是O(logn)，可以高效的查询和修改区间统计量。 线段树的组成线段树的每一个节点上隐式地存储着这个节点所“掌管”的区间，显式地存储着节点所“掌管”区间上的某一或某些统计量。需要注意的是，这些统计量必须满足区间加法（如区间最大值是子区间最大值中的最大值，区间和为子区间和的和等），众数、最长上升子序列等不符合区间加法。如果要用结构体实现，它的节点定义将会是这样的: 1234struct node&#123; node *ls,*rs; //ls为节点左子节点的指针，rs为右子节点的指针 int sum,mx; //统计量，常用的是区间和以及区间最值&#125; 显然，如果给定一个数组a1,a2…an,以[1,n]为范围建立线段树，那么根节点所掌管的区间（这里的区间是指数组下标，而不是数字范围）就是[1,n]，而其左子节点掌管的区间是[1,n/2],右子节点掌管的区间是[n/2+1,n]。以此类推可以知道每一个节点所掌管的区间，这也就是为什么我说每一个节点上隐式地存储着这个节点所“掌管”的区间的原因。以区间[1,10]为例，一棵建好的线段树每一个节点所掌管的区间情况如下图所示： 线段树的结构体实现线段树可以用结构体和指针来实现，也可以用数组来实现，结构体的实现较为容易理解，因此本文将先用结构体来实现线段树，在本文最后会给出数组的实现方法。 区间加法用一个节点两个子节点的统计量来更新自己的统计量。具体见代码： 1234void pushup(node *rt)&#123; rt-&gt;mx = max(rt-&gt;ls-&gt;mx,rt-&gt;rs-&gt;mx); rt-&gt;sum = rt-&gt;ls-&gt;sum + rt-&gt;rs-&gt;sum;&#125; 这个函数在构造和修改值的过程中都会用到。 线段树的构造线段树的构造是一个递归建树的过程，这里直接贴上代码，边读代码边解释。 1234567891011121314//首先解释一下这5个参数//[L,R]是建立线段树所依赖的数组范围，在递归过程中不变//rt是当前递归到的指针，[l,r]是当前指针所掌管的区间，这3个变量将作为状态在递归过程中传递void build(int L,int R,int l,int r,node *rt)&#123; //如果当前指针掌管的范围只有一个元素，直接赋值并返回 if(l == r)&#123;rt -&gt; sum = a[l];rt -&gt; mx = a[r];return;&#125; //找到区间的中点 int m = (l+r) &lt;&lt; 1; //递归构造左子树和右子树 build(L,R,l,m,rt-&gt;ls); build(L,R,m+1,r,rt-&gt;rs); pushup(rt); return;&#125; 在主函数中呼叫构造函数时的初始状态通常为build(1,N,1,N,root)。 线段树的修改线段树的修改步骤大致分为两步：1.从根节点开始查找我要修改的值所在的叶节点。（没有子节点的节点称为叶节点）2.修改叶节点，沿着查找路径递归更新与该叶节点相连的所有节点。代码如下： 123456789101112131415//再来解释一下这5个参数//P是我要修改的值所在的位置，V是我要将其修改为的值//l,r,rt的含义与build中相同void update(int P,int V,int l,int r,node *rt)&#123; //找到了目标叶节点，更新叶节点的值，显然此时l=r=P if(l==r)&#123;rt-&gt;sum=V;rt-&gt;mx=V;return&#125;; //同样找出区间中点 int m = (l+r) &lt;&lt; 1; //如果目标叶节点在区间左半，向左子树找，否则向右子树找 if(P&lt;=m) update(P,V,l,m,rt-&gt;ls); else update(P,V,m+1,r,rt-&gt;rs); //递归更新与被修改的叶节点相连的所有节点 pushup(rt); return;&#125; 在主函数中呼叫时的方式是update(P,V,1,N,root)其中P、V的含义见代码注释。 线段树的查询到了最重要的查询步骤了，查询最值与查询区间和的方法大同小异。从根节点开始向下搜索，如果要查询的区间完全包含（可以相等）某一节点所掌管的区间，将这个区间的统计量加入到最终结果中；如果要查询的区间不能完全包含某一节点所掌管的区间，继续拆分这个区间直到要查询的区间能够完全包含它。具体见代码实现： 1234567891011121314151617//查询最值//[L,R]是要查询的区间//l,r,rt的含义与之前相同int querymx(int L,int R,int l,int r,node *rt)&#123; //如果查询区间完全包含当前节点所掌管的区间，返回最大值 if(L &lt;= l &amp;&amp; R &gt;= r) return rt-&gt;mx; //初始化最大值为负无穷 int res = -inf; //求出线段中点 int m = (l+r) &lt;&lt; 1; //L&lt;=m说明要查询的区间可以继续往左子树拆分 if(L &lt;= m) res = max(res,querymx(L,R,l,m,rt-&gt;ls)); //R&gt;=m+1说明要查询的区间可以继续往右子树拆分 if(R &gt;= m+1) res = max(res,querymx(L,R,m+1,r,rt-&gt;rs)); //最终得出结果 return res;&#125; 注意在上述代码中L&lt;=m和R&gt;=m+1并不是if和else的关系，一个线段可以同时既可以往左拆分也可以往右拆分（例如要查询的区间是[4,6]而当前节点掌管的区间是[1,10]），但2种情况至少成立1种（否则L就会大于R），因此-inf并不会被计算到最终结果中去。查询区间和的方法类似，只要进行简单修改就可以了： 12345678int querysum(int L,int R,int l,int r,node *rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return rt-&gt;sum; int res = 0; int m = (l+r) &lt;&lt; 1; if(L &lt;= m) res += querysum(L,R,l,m,rt-&gt;ls); if(R &gt;= m+1) res += querysum(L,R,m+1,r,rt-&gt;rs); return res;&#125; 其实只是改变了统计量的“区间加法”部分的代码，注意此时res只能被初始化为0。 线段树的数组实现说明完线段树的结构体实现，接下来就是线段树的数组实现了，大部分代码与结构体实现类似，只是把节点抽象到了统计量数组的下标上，此时对于任意一个节点$rt$，它的左子节点是$rt * 2$,它的右子节点是$rt * 2+1$,个人习惯用rt&lt;&lt;1表示$rt * 2$,用rt&lt;&lt;1|1表示$rt * 2+1$。数组实现线段树的方法代码较为简洁，但理解起来稍有些抽象。这里是一道例题：HDU1754以下给出完整的AC代码（数组实现线段树的模版）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200000 + 5;const int inf = 0x3f3f3f3f;int N,M,mark[maxn],Max[maxn&lt;&lt;2]; //数组要开到区间长度的4倍确保空间够用//更新当前节点void pushup(int rt)&#123; Max[rt] = max(Max[rt&lt;&lt;1],Max[rt&lt;&lt;1|1]);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号void build(int l,int r,int rt)&#123; if(l == r)&#123;Max[rt] = mark[l];return;&#125; int m = (l+r) &gt;&gt; 1; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 [L,R]查询的区间int query(int L,int R,int l,int r,int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return Max[rt]; int m = (l+r) &gt;&gt; 1; int res = 0; if(L &lt;= m) res = max(res,query(L,R,l,m,rt&lt;&lt;1)); if(R &gt; m) res = max(res,query(L,R,m+1,r,rt&lt;&lt;1|1)); return res;&#125;//l:当前节点的左端点 r：当前节点的右端点 rt:当前节点的编号 将L的值改为Vvoid update(int L,int V,int l,int r,int rt)&#123; if(l==r)&#123;Max[rt]=V;return;&#125;; int m = (l+r) &gt;&gt; 1; if(L &lt;= m) update(L,V,l,m,rt&lt;&lt;1); else update(L,V,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; while(scanf(\"%d%d\",&amp;N,&amp;M) != EOF)&#123; for(int i = 1; i &lt;= N; ++i) scanf(\"%d\",&amp;mark[i]); build(1,N,1); char c; int a,b; while(M--)&#123; scanf(\" %c%d%d\",&amp;c,&amp;a,&amp;b); if(c=='Q') printf(\"%d\\n\",query(a,b,1,N,1)); else update(a,b,1,N,1); &#125; &#125; return 0;&#125; 读者可以结合注释与前文结构体实现的代码进行对照理解。 后记又一个数据结构写完了，当然以后还会更新线段树的加强版：主席树、红黑树等，敬请期待咯~更新了区间修改的内容，欢迎阅读:线段树区间修改。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lotusir.github.io/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://lotusir.github.io/tags/线段树/"}]},{"title":"素数相关","date":"2019-07-02T11:00:44.000Z","path":"2019/07/02/prime/","text":"素数素数，就是因数只有1和自己的数，本文将介绍一些素数相关的内容。 素数筛一种快速找出一定范围内所有素数的方法。 埃拉托斯特尼筛法简称埃氏筛或埃筛，是一种十分好写也十分容易理解的素数筛法。原理十分简单，如果一个数是素数，那么他的任意倍数一定不是素数。因此我们首先假设所有数都是素数，接着从2开始找，2是素数，那么把它的所有倍数标记为非素数，从小到大开始筛，这样当我们找到一个数还没有被标记为非素数的话，它一定是一个素数，再次标记它的所有倍数为非素数，依此循环。下面给出代码： 1234567891011121314151617#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 4e3;//只筛到maxn以内的质数using namespace std;int not_prime[maxn],prime[maxn];void getprime()&#123; int cnt = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i])&#123; prime[cnt++] = i; for(int j = i + i; j &lt;= maxn; j+=i) not_prime[j] = 1; &#125; &#125;&#125; 欧拉筛法又名快速素数筛或欧筛，一听名字就知道它很快。那么为什么欧拉筛法比埃氏筛快呢，或者说，埃氏筛法哪里慢了？观察埃氏筛法，我们发现，同一个合数，它有可能被多个素数筛到，比如6被2筛到之后又会被3筛到，这就造成了多余的运算。而欧拉筛避免了这一点，在欧拉筛中每一个合数都只会被筛到一次，实现了线性复杂度O(n)。 过程简述欧筛的过程简述如下：1.与埃筛一样，将所有数假设为素数。2.从2开始遍历，如果遇到一个素数，那么将这个素数加入素数表。3.无论遇到的是不是素数，都遍历素数表（为了方便表述，设这个数为N，当前遍历到的素数为P），将$N*P$标记为非素数，如果此时N能够被P整除，那么结束素数表的遍历，否则继续遍历素数表。 过程模拟为了方便理解，这里给出10以内的素数的遍历过程。（已经理解的跳过分割线内的内容） 初始状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 0 0 0 0 0 0 0 素数表为空遍历到2时，2是素数，将2加入素数表，遍历素数表，$22=4$标记为非素数，因为2能整除2，结束素数表的遍历。此时状态：*not_prime数组**(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 0 0 0 0 0 素数表 2 接着遍历3，3是素数，将3加入素数表，遍历素数表会将6和9标记为非素数。此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 0 1 0 素数表 2 3 遍历4，4不是素数，不加入素数表，遍历素数表，会将8标记为素数（2能整除4，因此只遍历到2就结束素数表的遍历）此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 1 1 0 素数表 2 3 遍历5，5是素数，将5加入素数表，遍历素数表会把10，15，25标记为非素数。此时状态：not_prime数组(not_prime数值为0说明是素数) 1 2 3 4 5 6 7 8 9 10 1 0 0 1 0 1 0 1 1 1 素数表 2 3 5 实际上至此10以内的所有素数已经全部被筛出了，接着遍历6会将12标记为非素数，而遍历7会把14、21、35、49标记为非素数……在这个过程中，每一个合数都只会被筛到一次，证明略。 具体代码给出代码实现： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e6;using namespace std;int not_prime[maxn],prime[maxn];void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125; 相较于埃氏筛，欧拉筛法更快，且没有其他缺点，因此实际上只要记住欧拉筛就可以了埃氏筛比较好记就是了 分解素因数将一个大合数N分解成素因数的乘积，方法如下：1.用欧拉筛或埃氏筛得到素数表。2.从素数表中最小的素数P开始，如果N能够被P整除，那么将N /= P，并将P作为素因数的指数加一，重复这个步骤直到N不能被P整除。3.用下一个较大的素数重复第2步，直到取出大于$sqrt(N)$的第一个素数。4.如果N已经被除到了1，那么素因数分解完毕，如果N还没有被除到1，那么N最终的值是它自己的最后一个素因数。 用途较少，这里给出一道可用这种方法解答的例题：SHUOJ2只能用校内网连上，连不上就算了。。题意简述：给定正整数A,B（1&lt;=A,B&lt;=1000）,求$GCD(A,B^B)$。解题思路：由于B较大，显然不能直接求出$B^B$再求GCD，因此对A和B进行素因数分解，再将B的每一个素因数的指数乘以B，就能得出$B^B$的素因数，A和B的公共素因数的乘积就是所求的答案。AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 1e3;using namespace std;int not_prime[maxn],prime[maxn],cnt[2][35],A,B;void getprime()&#123; not_prime[1] = 1; int tot = 0; for(int i = 2; i &lt;= maxn; ++i)&#123; if(!not_prime[i]) prime[tot++] = i; for(int j = 0; j&lt;tot &amp;&amp; prime[j]*i &lt;= maxn; j++)&#123; int x = prime[j]*i; not_prime[x] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;//快速幂int qpow(int x,int y)&#123; int res = 1; while(y)&#123; if(y&amp;1) res = res * x; y &gt;&gt;= 1; x = x * x; &#125; return res;&#125;int main()&#123; getprime(); while(cin &gt;&gt; A &gt;&gt; B)&#123; memset(cnt,0,sizeof(cnt)); int t = B; for(int i = 0; i &lt;= 30; i++)&#123; while(A % prime[i] == 0)&#123;cnt[0][i]++;A /= prime[i];&#125; while(B % prime[i] == 0)&#123;cnt[1][i]++;B /= prime[i];&#125; cnt[1][i] *= t; &#125; int ans = 1; for(int i = 0; i &lt;= 30; i++)&#123; ans *= qpow(prime[i],min(cnt[0][i],cnt[1][i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 本题还有另一种做法,之后可能会补上。此外，有一件很奇怪的事就是当maxn取某些值的时候，prime[0]会莫名其妙变成1，暂时没有发现原因。。 后记素数相关的算法和思想还是比较重要的，HDU的多校赛经常出现GCD等相关问题。今天的训练赛打的真是自闭","tags":[{"name":"素数筛","slug":"素数筛","permalink":"https://lotusir.github.io/tags/素数筛/"},{"name":"分解因数","slug":"分解因数","permalink":"https://lotusir.github.io/tags/分解因数/"},{"name":"素数","slug":"素数","permalink":"https://lotusir.github.io/tags/素数/"}]},{"title":"ACM暑期训练赛（HDU07）","date":"2019-07-02T08:04:58.000Z","path":"2019/07/02/HDU07/","text":"2019/07/02 阴有雨又是自闭的一天2019/07/03 晴？阴？更新了B、C、H的题解 比赛地址：HDU07 HDU07A All Kill（待补） B Build a Tree题意：给出一棵有N个节点的完全K叉树，求这棵树所有子树大小异或后的答案。解题：待补，考虑将子树分为完整的K叉树和不完整的K叉树，不完整的k叉树至多只有一棵，单独处理这棵树，从树的最底层向上递归求解。 C Color the chessboard题意：给出一张矩形图，图上每一个单位矩形初始状态下被涂为白色或红色或蓝色，现在要将这张图上的每一个白色的单位矩形染上色，要求所有具有偶数行数和偶数列数的矩形中所含有的蓝色矩形和红色矩形数量相等。解题：待补，显然只要所有的2*2的矩形都满足条件，那么就能满足条件，DFS or DP？ D Destroy the cube(待补) E Euler theorem题意：给出若干个整数，对于每一个整数，要求输出这个整数余除以任意一个数能得到的余数的个数。（如，对于3，3%3=0,3%4=3,3%2=1,任何数都不能让3余2，因此有3个余数）。解题：签到题打表就能得到答案。显然，对于一个数N，任何数不可能让它余超过$(N-1)/2$，而任意不超过N/2的余数都是有可能得到的，因此最终的答案就是$N/2+2$(1~N/2以及0和N)。简单证明：要让$N$余一个数$m$，只要让他余除$N-m$就可以了，但当$m&gt;(N-1)/2$时$2(N-m)&lt;N+1$,即$2(N-m)&lt;=N$,这时$N$余除$(N-m)$的值就变成了$N$余除$2(N-m)$的值，显然这是一个小于$(N-1)/2$的值。 F Free from square题意：给出两个整数n,K（小于500），要求从1 ~ K中挑出n个整数，这些整数的乘积不能被任何完全平方数（除了1）整除，输出可行的方案数。解题：待补，显然不能选相同的数字，且选了一个数以后不能再选任何它的倍数。然后不会了 G Give out candies（待补） H Hard challenge题意：在二维坐标平面上给出若干个点的坐标和权值，保证任意两点所连成的直线不经过原点，任意两点间的边的权值等于这两点权值的乘积，现在要求过原点画一条直线，这条直线所穿过的边的权值之和最大，输出最大的权值。解题：代码待补1.首先，任何一条过原点的直线所穿过的边的权值之和，等于直线一边所有点的权值之和乘以直线另一边所有点的权值之和。2.根据原点到每一个点连线的斜率，可以将所画直线的斜率分成若干个区间，枚举这些区间就能得出答案。3.为了得到区间，首先需要将点按照斜率的不同进行排序（极序排序），接着按照第0个点到第1个点间，第1个点到第2个点间……的顺序进行枚举。4.可以在0 ~ 360°的区间内维护一个前缀和快速得出某一直线两边的点的权值之和。 I Inverse of sum（待补） J Just do it题意：给出一个数列a0a1a2……an，要求进行一种运算m次，这种运算就是将每一个ai变成bi，切bi的值等于原数列ai从a0异或到ai的结果。解题：待补，找规律？我找了个规律然后T了(┬＿┬) K Kolakoski题意：有一种特殊的数列，它的第一项是1，这个数列形如：1，2，2，1，1，2，1，2，2……，将这个数列相同的项合并会变成1，22，11，2，1，22……，计算每一项的位数作为新数列这一项的值会变成1，2，2，1，1，2……，我们发现这个数列变回了最初的数列，现在要求输出这个数列的第n项（n&lt;1e7）。解题：n的数值较小，直接用vector暴力模拟即可。简述模拟过程：1.首先初始化数列的前3项为1，2，22.接着将指针指向第3项（2）。3.沿着指针，如果发现了一个2，那么需要在队尾添加两个相同的数，但这个数要与前一个数不同，因此如果此时队尾元素是1那么push_back两个2，如果队尾元素是2那么push_back两个1；如果发现了一个1，那么push_back一个与队尾元素不同的数即可。贴上AC的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; s;int main()&#123; int t,temp; //模拟过程 s.push_back(1); s.push_back(2); s.push_back(2); for(int i=2;i&lt;1e7+5;i++) &#123; temp = s.size() - 1; if(s[i] == 1) &#123; if(s[temp] == 1) &#123; s.push_back(2); &#125; else &#123; s.push_back(1); &#125; &#125; else &#123; if(s[temp] == 2) &#123; s.push_back(1); s.push_back(1); &#125; else &#123; s.push_back(2); s.push_back(2); &#125; &#125; &#125; //模拟结束 cin&gt;&gt;t; while(t--) &#123; int n; cin&gt;&gt;n; cout&lt;&lt;s[n-1]&lt;&lt;endl; &#125;&#125; L Loop next（待补） M Mystery（待补） 看看明天能补几道吧。。(┬＿┬) 补题日记7/3H Hard challenge解题：大致解法与昨天写的差不多，不过实际写代码的时候有一些问题，因此做了一些改变，改变后的解题方法如下：1.将所有点按照斜率k从大到小的顺序排序。2.初始状态下让所画的直线竖置，这样将所有点分为直线左边的点与直线右边的点两组（特别注意在y轴上的点分在直线右边，此时可以认为直线并不完全竖置），输入时统计直线左边的点权和lsum和直线右边的点权和rsum。3.维护lsum和rsum。按k从大到小的顺序遍历每一个点，每一次改变直线将这个点的分组改变（由于已经按k排序，每次移动直线只会有一个点的分组被改变），根据这个点的位置对lsum和rsum做出相应的变化。4.昨天维护前缀和的问题在于0 ~ 360°并不是一个离散的范围而是一个连续的范围，前缀数组的维护有难度。貌似也是可以的，但我懒得想了以下是AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 5e4+200;const int inf = 0x3f3f3f3f;using namespace std;struct points&#123; int x,y,val; double k;//斜率&#125;P[maxn];int n,T;ll lsum,rsum,ans;bool cmp(points a,points b)&#123; return a.k&gt;b.k;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; lsum = 0;rsum = 0; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; P[i].x &gt;&gt; P[i].y &gt;&gt; P[i].val; //计算出斜率 P[i].k = atan(1.0*P[i].y/P[i].x); //预设lsum和rsum状态 if(P[i].x &lt; 0) lsum += P[i].val; else rsum += P[i].val; &#125; //按斜率排序 sort(P,P+n,cmp); //预设ans状态 ans = lsum * rsum; //遍历，维护lsum、rsum和ans for(int i = 0; i &lt; n; ++i)&#123; if(P[i].x &gt; 0)&#123; lsum += P[i].val; rsum -= P[i].val; &#125; else&#123; lsum -= P[i].val; rsum += P[i].val; &#125; ans = max(ans,lsum*rsum); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B Build a tree我的数据结构是真的菜啊解题：显然，题目给出的是一个有n个节点的完全k叉树，观察这课树，不难发现，除了第一层和最后一层，每一层至多只有一棵子树不是满k叉树，而这棵子树左边的所有子树是满k叉树，右边是深度小一的满k叉树（画张图就很清楚了），因此按以下步骤求解：1.预处理，用一个数组记录每一层最后一个节点的编号，同时得到树的深度。2.首先单独处理最后一层，将可能不是满k叉树的那几个节点单独挑出，并标记最后一个节点，其余统一进行异或。3.向上遍历，每一层由三部分组成：①最深的满k叉树②不满的那棵k叉树③浅一层的k叉树。每次遍历一层将标记上传的父节点，这个节点就是那棵可能不满的k叉树，左边是较深的k叉树，右边是较浅的k叉树。很容易得到满k叉树的size和数目，因此统一异或。不满的k叉树的size等于这一层以下（包含这一层）的总节点数减去左边满k叉树的size之和再减去右边满k叉树的size之和。4.一直遍历到树的第一层，结束遍历。5.显然遍历的时间复杂度是$logk(n)$，只要k&gt;=2，是很快就能遍历完的，但当k=1是遍历会很慢，因此打表特判。下面给出AC代码，代码比较丑，将就一下吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int T;//num记录每一层最后一个节点的编号，pos是非满k叉树节点的编号//LSize是pos左边满k叉树的size，RSize同理//ex是单独处理的子树的异或结果,restSize是非满k叉树的sizell n,k,num[70],dep,pos,LSize,RSize,nowdep,ex,restSize;ll qpow(ll a,ll b)&#123; ll res = 1; while(b)&#123; if(b&amp;1) res *= a; b &gt;&gt;= 1; a*=a; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; k; //特判k=1的情况 if(k == 1)&#123; ll tmp = n % 4; if(tmp == 0) cout &lt;&lt; n &lt;&lt; '\\n'; if(tmp == 1) cout &lt;&lt; 1 &lt;&lt; '\\n'; if(tmp == 2) cout &lt;&lt; n+1 &lt;&lt; '\\n'; if(tmp == 3) cout &lt;&lt; 0 &lt;&lt; '\\n'; continue; &#125; else&#123; ll i = 0,ans = n; num[0] = 0; //找出每一层最后一个节点的编号以及树的深度 while(num[i] &lt; n - 1 &amp;&amp; num[i] &lt;= n - 1 - qpow(k,i+1))&#123; num[i+1] = num[i] + qpow(k,i+1); i++; &#125; pos = n - 1; //可能组成非满2叉树的节点数 restSize = (pos-num[i])%k; ans ^= (((pos-num[i])-restSize) &amp; 1); ex = ((restSize&amp;1)?1:0); //深度是i+1，原因自己看上面的while条件，主要是怕他溢出ll。。 dep = i + 1; //最后一层已经处理完，开始处理倒数第二层 nowdep = i; LSize = 1; RSize = 0; //ans初始化为n，因此不用再算第一层，算到第2层就可以结束了 while(nowdep &gt; 0)&#123; //上传标记 pos = (pos-1)/k; //计算左满k叉树，右满k叉树以及非满k叉树的size LSize = LSize * k + 1; RSize = RSize * k + 1; restSize = (n - 1 - num[nowdep-1])- (pos-num[nowdep-1]-1)*LSize - (num[nowdep]-pos)*RSize; ex ^= restSize; ans ^= (((pos-num[nowdep-1]-1)&amp;1)?1:0)*LSize; ans ^= (((num[nowdep]-pos)&amp;1)?1:0)*RSize; nowdep--; &#125; //最终结果异或上单独处理的子树 ans ^= ex; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; C Color the chessboard解题：昨天想的没错，只要2 * 2的矩形满足，整个图就能满足，将各种2 * 2的矩形排列一下，你或许会发现，将R看做1，B看做0，所有答案一定满足2种情况之一：1.不考虑列的情况，每一行一定是01循环或10循环之一。2.不考虑行的情况，每一列一定是01循环或10循环之一。其次，只要满足上述两种情况之一，那么一定是一种答案。因此分2次暴力跑出能否满足上述2种情况之一，将两种情况的可能数相加。有2种情况可能会被重复计算，也就是行和列同时满足01循环或10循环的情况，单独跑出能否满足这种情况，能满足则减一。具体可以结合这篇文章一起理解，我的代码也是几乎照抄了一遍这篇文章的。。以下是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll mod = 998244353;int T,n,m;ll ans,ans1,ans2;int M[2000][2000];char C[2000][2000];bool flag;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j)&#123; cin &gt;&gt; C[i][j]; if(C[i][j] == 'R') M[i][j] = 1; if(C[i][j] == 'B') M[i][j] = 0; if(C[i][j] == '?') M[i][j] = -1; &#125; ans1 = 1; for(int i = 1; i &lt;= n; ++i)&#123; //cnt是每一行选择的可能性，显然总的可能性要相乘得出 ll cnt = 0; flag = true; for(int j = 1; j &lt;= m; ++j)&#123; if(j%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if(j%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; flag = true; for(int j = 1; j &lt;= m; ++j)&#123; if(j%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if(j%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; ans1 = (ans1*cnt)%mod; if(ans1 == 0) break; &#125; ans2 = 1; for(int j = 1; j &lt;= m; ++j)&#123; ll cnt = 0; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; if(i%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if(i%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; if(i%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if(i%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(flag) cnt++; ans2 = (ans2*cnt)%mod; if(ans2 == 0) break; &#125; ans = (ans1+ans2)%mod; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= m; ++j)&#123; if((i+j)%2==1 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; if((i+j)%2==0 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; &#125; if(!flag) break; &#125; if(flag) ans = (ans-1+mod)%mod; flag = true; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= m; ++j)&#123; if((i+j)%2==1 &amp;&amp; M[i][j] == 0)&#123;flag = false;break;&#125; if((i+j)%2==0 &amp;&amp; M[i][j] == 1)&#123;flag = false;break;&#125; &#125; if(!flag) break; &#125; if(flag) ans = (ans-1+mod)%mod; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 代码中的break都是用来剪枝的，剪枝以后变慢了，姑且是能懂了，不过总感觉有些不能释怀，比赛时真的能想通吗。。。 7/3补题小结今天暂时补到这了，感觉还是经验不够啊？？还是我太菜了这几题能看懂但总觉得比赛的时候想不到。","tags":[{"name":"自闭","slug":"自闭","permalink":"https://lotusir.github.io/tags/自闭/"}]},{"title":"图论最小生成树","date":"2019-07-02T03:36:55.000Z","path":"2019/07/02/minTree/","text":"最小生成树本文会介绍两种用于获取最小生成树的算法，同样只给出用法不给出证明。 引入最小生成树通常用于解决形如以下的这种问题：给定若干个点和若干个边，保证这些边能将这些点全联通，试从这些边中选出部分边，使生成的树的边权之和最小。当然ACM的题通常都会有一个场景，比如有许多城镇，现已知这些城镇间的距离，要在这些城镇间修路，保证联通所有城镇的同时使得所修的路最短。 最小生成树算法下文会介绍两种算法Prim和Kruscal算法,这两种算法都会采用贪心的策略。 PrimPrim是一种以点为主体的贪心算法。下面简述算法的过程：1.在所有点中任取一点作为树的根，更新其他所有点到树的距离。2.在未被选取的点中，找到离树最近的点并选入树中，再次更新其他所有点到树的距离。3.重复第2步，直到所有点都被选入树中，Prim算法到此结束。点到树的距离是指点到树上任意一点的最短距离注意给出的图有多个最小生成树，根据选取的起点不同可能的到不同的最小生成树，但如果最小生成树唯一，那么起点的选取不会影响最终得到的最小生成树，所以放心大胆地去选取起点吧！ 下面给出prim算法主体的代码： 123456789101112131415161718192021222324void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125; 本算法中采用邻接矩阵以及暴力遍历找最小值的方式实现，理论上可以用优先队列和邻接表实现。 同样给出例题：hdu1233以下是AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn = 200;const int inf = 0x3f3f3f3f;using namespace std;int N,dis[maxn][maxn],vis[maxn],ans,mndis[maxn];void prim()&#123; //初始化，将1号点加入到生成树中 ans = 0; int cnt = 1; vis[1] = 1; for(int i = 1;i &lt;= N;++i) mndis[i]=dis[1][i]; while(cnt != N)&#123; int mn = inf,id; //找出所有点中距离生成树最近的点 for(int i = 1; i &lt;= N; i++)&#123; if(!vis[i] &amp;&amp; mndis[i] &lt; mn)&#123; mn = mndis[i]; id = i; &#125; &#125; //将找到的点加入生成树 vis[id] = 1; ans += mn; cnt++; //更新剩余点到树的距离 for(int i = 1; i &lt;= N; i++) mndis[i] = min(mndis[i],dis[id][i]); &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin &gt;&gt; N)&#123; if(!N) break; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); int T = N * (N - 1) / 2; while(T--)&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; dis[a][b] = dis[b][a] = c; &#125; prim(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; KruscalKruscal是一种以边为主体的贪心算法，下面简述算法过程。1.从所有没有使用过的边中找出最短的一条边，标记为使用过了。2.如果边的两个端点不在一棵树中，那么将这条边加入到树中，否则不加入。3.重复1、2步直到所有点被联通（显然联通n个点需要n-1条边）。 找最短边的过程可以用优先队列实现，而判断端点是否在同一棵树中，可以用并查集实现，如果不会并查集，可以先阅读这篇文章，下面代码中的Find和Union函数毁在这篇文章中给出模版。下面给出Kruscal算法的主体代码： 12345678910111213141516171819void kruscal()&#123; int ans = 0,cnt = 0; //选取最短边直到没有边可以再选或者图已经联通 while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; //利用并查集判断是否在同一棵树中，如果不在则加入树中 if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; //没有选取到M-1条边（M为点的数量），说明图不能联通 if(cnt != M-1) puts(\"?\"); //图已联通，输出最小边权和 else printf(\"%d\\n\",ans);&#125; 同样给出例题：hdu1683AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;const int maxn = 200;using namespace std;struct edge&#123; int from; int to; int val; edge(int a = 0,int b = 0,int c = 0)&#123;from=a;to=b;val=c;&#125; friend bool operator &gt; (edge a,edge b)&#123; return a.val &gt; b.val; &#125;&#125;;int N,M,father[maxn];priority_queue&lt; edge,vector&lt;edge&gt;,greater&lt;edge&gt; &gt; Q;int Find(int a)&#123; if(father[a]==a) return a; return father[a]=Find(father[a]);&#125;void Union(int a,int b)&#123; int f1=Find(a),f2=Find(b); father[f2] = f1;&#125;void init()&#123; for(int i = 1; i &lt;= M; ++i) father[i]=i; while(!Q.empty()) Q.pop();&#125;void kruscal()&#123; int ans = 0,cnt = 0; while(!Q.empty() &amp;&amp; cnt != M-1)&#123; edge temp = Q.top(); Q.pop(); int f = temp.from,t = temp.to,v = temp.val; if(Find(t)!=Find(f))&#123; Union(f,t); cnt++; ans+=v; &#125; &#125; if(cnt != M-1) puts(\"?\"); else printf(\"%d\\n\",ans);&#125;int main()&#123; while(scanf(\"%d\",&amp;N))&#123; if(N==0) break; scanf(\"%d\",&amp;M); init(); for(int i = 0; i &lt; N; i++)&#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); Q.push(edge(a,b,c)); &#125; if(N&lt;M-1)&#123;puts(\"?\");continue;&#125; kruscal(); &#125; return 0;&#125; 后记以上就是两种最短路算法的实现过程了。后记不知道写啥了，就这样吧","tags":[{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"贪心","slug":"贪心","permalink":"https://lotusir.github.io/tags/贪心/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://lotusir.github.io/tags/最小生成树/"}]},{"title":"图论最短路","date":"2019-07-01T14:40:31.000Z","path":"2019/07/01/minpath/","text":"最短路算法本文将介绍几种用于解决最短路问题的算法，仅给出用法，不给出证明（因为不会证明）。 问题简述最短路问题：给出若干个点和若干个带有边权的边，要求找出从某点到某点的最短路径。 邻接表简单来说就是为每一个点建立一个边链表记录了与这个点所连的所有边。实现方法很多，本文用vector实现。 123//edge为边的结构体，maxn为点的总数，E[i]中记录了与点i相连的所有边//如果题目为无向图，注意要push_back两个方向的边vector&lt;edge&gt; E[maxn]; 单源最短路即仅要求求出从一个点到其他所有点（某一点）的最短距离的问题。 dijkstra我将dijkstra认识为一个贪心的BFS过程，首先，我们需要用到两个结构体。1.边，这个结构体必须包含目标点，边权，可以包含出发点（也可以不包含）。 12345struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;; 2.状态，这个结构体需要包含当前所在的位置（影响联通路径的状态）和已经走过的距离，同时重载&gt;号，比较的依据为走过的距离，重载&gt;号是为了能够使用priority_queue。 123456789struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;; 有了这两个结构体之后，我们就能开始dijkstra的主体了，简单地描述一下dijkstra的过程。1.录入数据。2.创建一个nod的优先队列，从小的开始出队列。3.将初始态（初始位置，经过的距离为0）push进优先队列，设初始最短路径都为无穷大。4.弹出队首元素，更新与队首位置相连的所有点，如果能够更新（距离变小了）某个点，则将这个点push进队列。5.重复第4步直到队列为空，这意味着没有点能够再次被更新了，dijkstra算法到此结束。下面给出算法主体代码： 12345678910111213141516171819202122232425void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; //优先队列，从较小的开始出 Q.push(nod(N,0));//初始态,N为出发点 //类似BFS过程 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; //若能更新，则更新并把更新的点push进队列 if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125; 需要注意的是，dijkstra算法并不能判断负环，因此当题目中出现负边时慎用。 这里给出一道例题：POJ2387AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int maxn = 1000+50;const int inf = 0x3f3f3f3f;using namespace std;struct edge&#123; int to; int val; edge(int a = 0,int b = 0)&#123;to=a;val=b;&#125;&#125;;struct nod&#123; int pos; int d; nod(int a = 0,int b = 0)&#123;pos=a;d=b;&#125; //优先队列重载大于符号 friend bool operator &gt; (nod a, nod b)&#123; return a.d&gt;b.d; &#125;&#125;;//邻接表vector&lt;edge&gt; E[maxn];int T,N,dis[maxn];//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....//加边，无向图时添加两条边void add(int f,int t,int v)&#123; E[f].push_back(edge(t,v)); E[t].push_back(edge(f,v)); return;&#125;void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(N,0));//初始态,N为出发点 while(!Q.empty())&#123; nod temp = Q.top(); int pos = temp.pos; int d = temp.d; Q.pop(); if(d &gt; dis[pos]) continue; dis[pos]=d; //遍历邻接表更新相邻点的最短距离 for(int i = 0; i &lt; E[pos].size(); ++i)&#123; int to = E[pos][i].to; int val = E[pos][i].val; int nd = d + val; if(nd &lt; dis[to])&#123; dis[to] = nd; Q.push(nod(to,nd)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T &gt;&gt; N; while(T--)&#123; int from,to,val; cin &gt;&gt; from &gt;&gt; to &gt;&gt; val; add(from,to,val); &#125; dij(); cout &lt;&lt; dis[1] &lt;&lt; endl; return 0;&#125; 以下内容较难，可跳过此外，虽然在上题中dis[i]表示从起点到i点的最短距离，但实际上这个dis数组的下标代表的是一个状态，本题中状态只有所在的点，因此dis数组也只需要一个下标，dis数组的下标可以根据需要扩充。例如在hdu6071中，dis[i][j]表示的就是跑到了i点且跑过的距离模mod后为j的一个状态，我们也可以将每一种状态抽象为不同的点。同样给出AC代码（本题较难，可能另开文章单独解释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;typedef long long ll;const int maxn = 6e5+20;const int mod = 998244353;const int inf = 0x3f3f3f3f;const ll llinf = 0x3f3f3f3f3f3f3f3f;using namespace std;struct edge&#123; ll from; ll to; ll val; edge(ll a = 0,ll b = 0,ll c = 0)&#123;from=a;to=b;val=c;&#125;&#125;;struct nod&#123; ll pos; ll d; nod(ll a=0,ll b=0)&#123;pos = a;d = b;&#125; friend bool operator &gt; (nod a,nod b)&#123; return a.d &gt; b.d; &#125;&#125;;ll T,k,d12,d23,d34,d41,m,dis[5][maxn];vector&lt;edge&gt; E[5];void dij()&#123; memset(dis,inf,sizeof(dis)); priority_queue&lt; nod,vector&lt;nod&gt;,greater&lt;nod&gt; &gt; Q; Q.push(nod(2,0)); while(!Q.empty())&#123; nod t = Q.top(); Q.pop(); if(t.d &gt; dis[t.pos][t.d%m]) continue; for(vector&lt;edge&gt;::iterator it = E[t.pos].begin(); it != E[t.pos].end(); it++)&#123; ll nd = t.d+(*it).val; if(nd &lt; dis[(*it).to][nd%m])&#123; dis[(*it).to][nd%m] = nd; Q.push(nod((*it).to,nd)); &#125; &#125; &#125;｝int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &gt;&gt; T; while(T--)&#123; for(int i = 1; i &lt;= 4; ++i) E[i].clear(); cin &gt;&gt; k &gt;&gt; d12 &gt;&gt; d23 &gt;&gt; d34 &gt;&gt; d41; E[1].push_back(edge(1,2,d12));E[2].push_back(edge(2,1,d12)); E[2].push_back(edge(2,3,d23));E[3].push_back(edge(3,2,d23)); E[3].push_back(edge(3,4,d34));E[4].push_back(edge(4,3,d34)); E[4].push_back(edge(4,1,d41));E[1].push_back(edge(1,4,d41)); m = 2 * min(d12,d23); dij(); ll ans = llinf; for(int i = 0; i &lt; m; i++)&#123; if(dis[2][i] &gt;= k) ans = min(ans,dis[2][i]); else&#123; ll delt = k - dis[2][i]; dis[2][i] += (delt/m+(delt%m?1:0))*m; ans=min(ans,dis[2][i]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 至此，dijkstra算法的介绍告一段落。 SPFA(待补)同样为单源最短路算法，相较于dijkstra的优势是可以判断负环，劣势是比较慢。是优化版的Bellman-Ford算法。模版及例题待补 Bellman-Ford他死了。 多源最短路给定若干点以及点之间的距离(边)，要求求出任意两点间的最短距离。 Floyed算法又名Warshall算法。暴力遍历O($n^3$)次点，对于任意两点i,j，如果以k为桥梁能使i ~ j的距离变短，那么更新i ~ j的距离。由于算法特性，只能用邻接矩阵来存图。算法主体代码： 1234for(int k = 1; k &lt;= n; k++)for(int i = 1; i &lt;= n; i++)for(int j = 1; j &lt;= n; j++)w[i][j] = min(w[i][j], w[i][k] + w[k][j]); 给出一道例题：poj2139AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;typedef long long ll;const int inf = 0x3f3f3f3f;using namespace std;int w[303][303], tmp[303];int main()&#123; int n, m, t; scanf(\"%d %d\", &amp;n, &amp;m); memset(w, inf, sizeof(w)); for(int i = 1; i &lt;= n; i++) w[i][i] = 0; while(m--) &#123; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; tmp[i]; &#125; for(int i = 0; i &lt; t; i++) for(int j = 0; j &lt; i; j++) w[tmp[i]][tmp[j]] = w[tmp[j]][tmp[i]] = 1; &#125; for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); double ans = inf; for(int i = 1; i &lt;= n; i++) &#123; int sum = 0; for(int j = 1; j &lt;= n; j++) sum += w[i][j]; ans = min(ans, sum * 100 * 1.0/ (n - 1)); &#125; printf(\"%d\\n\", (int)ans); return 0;&#125; 非常简单的一个算法，但是他的空间复杂度和时间复杂度都过高，并不常用。 后记好吧，从篇幅上可以看出，最短路算法中最常用，最强大的算法就是dijkstra了，他的变形也有很多，需要好好掌握哦！本文中一些STL会在将来的文章里补上用法。emmm可能会吧","tags":[{"name":"图论","slug":"图论","permalink":"https://lotusir.github.io/tags/图论/"},{"name":"贪心","slug":"贪心","permalink":"https://lotusir.github.io/tags/贪心/"},{"name":"最短路问题","slug":"最短路问题","permalink":"https://lotusir.github.io/tags/最短路问题/"}]},{"title":"Trie","date":"2019-07-01T13:24:40.000Z","path":"2019/07/01/Trie/","text":"TrieTrie，也叫做字典树，是一种树形结构，可以高效的存储字符串和查询字符串。 Trie比较简单，这里只做简单的介绍，并给出例题和模版。例题：hdu1251题意简述：给定一系列字符串，再给出多个前缀，输出这些前缀在多少个字符串中出现过。 Trie的组成这种树形结构只有一个根节点，根节点没有意义（虚节点）。网上很多文章中将每一个节点视为一个字符，但事实并非如此，在Trie中，每一条边代表了一个字符，而从根节点走到某一节点路径上所有字符组成的字符串，则为该节点所代表的字符串。为了方便讲解，这里直接给出Trie节点的定义： 123456789101112struct trie&#123; trie *nxt[26]; //子节点的指针数组，此处26为字符集的大小，可以根据需求修改 int cnt; //此题用于统计前缀，根据需求修改 //初始化 trie() &#123; cnt = 1; //初始化所有nxt为NULL memset(nxt,NULL,sizeof(nxt)); &#125;&#125;; 我们可以认为，从一个节点p到节点p-&gt;nxt[id]的边所代表的字符即为id所映射的字符。以a ~ z映射到0 ~ 25为例，root-&gt;nxt[0]-&gt;nxt[1]-&gt;nxt[2]节点所代表的的字符串就是abc。 Trie的构建与线段树不同，Trie并不是输入完所有字符串后统一构建的(当然你想这么做也是可以的，但是会MLE),Trie的构建通常是输入一个字符串就插入一个字符串，插入的过程很简单，如果nxt[id]已经存在就沿着走，如果不存在就新建一个。以下为代码实现： 12345678910111213141516171819202122void Insert(char *s)&#123; trie *p = root; i = 0; //遍历字符串 while(s[i])&#123; id = s[i] - 'a'; //如果存在，就沿着走，并操作路径上的统计量（此处用于统计前缀） if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; //如果不存在，就新建，当然也要走过去 else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125; Trie的查询字典树的查询视题意而定，在本次例题中，为统计前缀出现的次数。根据字符串沿着树遍历即可，若遇到nxt[id]==NULL的情况，说明没找到，直接返回0。以下为代码实现 12345678910111213141516int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; //找得到就沿着走 if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; //找不到直接返回0 else return 0; i++; &#125; //若找到了，返回最终节点的cnt值 return p -&gt; cnt;&#125; Trie的删除递归删除即可 123456void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125; 例题+模版回到例题的解答，解题过程非常简单毕竟是模版题1.根据给出的字符串建立Trie2.根据前缀在Trie上遍历 AC代码（模版）：本题用C++提交的，用G++提交有惊喜哦本题G++提交会MLE，请用C++提交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const int maxn = 11;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; int cnt; trie() &#123; cnt = 1; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int i,id;char S[maxn],s1[maxn];void Insert(char *s)&#123; trie *p = root; i = 0; while(s[i])&#123; id = s[i] - 'a'; if(p-&gt;nxt[id]) &#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else &#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; i++; &#125;&#125;int query(char* s)&#123; trie *p = root; i = 0; while(s[i]) &#123; id = s[i] - 'a'; if(p -&gt; nxt[id]) p = p -&gt; nxt[id]; else return 0; i++; &#125; return p -&gt; cnt;&#125;void Free(trie *p)&#123; for(i = 0; i &lt; 26; ++i) if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); delete(p); p = NULL;&#125;int main()&#123; root = new trie; while(scanf(\"%s\",S))&#123; Insert(S); cin.get(); if(cin.peek() == '\\n') break; &#125; while(scanf(\"%s\",s1) != EOF)&#123; printf(\"%d\\n\",query(s1)); &#125; return 0;&#125;","tags":[{"name":"Trie","slug":"Trie","permalink":"https://lotusir.github.io/tags/Trie/"},{"name":"字符串","slug":"字符串","permalink":"https://lotusir.github.io/tags/字符串/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lotusir.github.io/tags/数据结构/"}]},{"title":"AC自动机","date":"2019-07-01T11:10:50.000Z","path":"2019/07/01/ACautoman/","text":"AC自动机AC自动机，用于多模字符串匹配，类似KMP+Trie。最近越来越觉得AC自动机又神奇有有意思，顶上来再看看。 一种最常见的题目如下（裸题模版）题意简述：首先输入多个单词（模式串），接着输入一串目标字符串，输出有多少个模式串在目标字符串中出现过。解题步骤：1.根据给出的模式串构造一个Trie树。2.在Trie树上构造fail指针（构造Trie图）。3.将目标字符串在Trie图上进行匹配。 2019-07-07补充几个AC自动机的特点：1.将目标串在由模式串组成组成的AC自动机上跑一遍以后，只要任一节点所代表的字符串是目标串的子串，它就会被遍历到。2.即使节点不是字符串的结束节点，它也会被遍历到，且在目标串中出现几次就会被遍历到几次，如果希望不要重复遍历要打上标记。3.以上两点都是由fail指针的特点和匹配过程导出的。4.通常AC自动机的题都是构造题，我们需要把问题转换成多模子串匹配问题。 Fail指针Fail指针的构造过程：1.用BFS的顺序逐层向下构造Fail指针。2.当一个节点的父亲指针为Root时，将Fail指针指向Root。3.当要获取一个节点（父节点不为Root）的Fail指针时，从其父亲指针的Fail指针开始查找与自己同名的子节点，若找到，则这个节点的Fail指针指向该与自己同名的子节点；若找不到，则沿着Fail指针继续寻找直到找到或直到指向Root时仍找不到。若指向根节点时仍然找不到，及当前节点没有Fail指针，将Fail指针指向Root。具体代码如下： 12345678910111213141516171819202122232425262728293031323334void getFail()&#123; queue&lt;trie*&gt; q; //用于BFS q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; //父节点为root的节点fail指针指向root if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; //从父节点的fail指针开始查找 temp = p -&gt; fail; //当temp为NULL时即没有找到同名的子节点 while(temp)&#123; //找到了与自己同名的子节点，则让当前节点的fail指向该子节点，同时结束循环 if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; //沿着fail指针继续查找 temp = temp -&gt; fail; &#125; //temp为NULL，即没有找到同名的子节点，将fail指针指向root if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; //bfs q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125; Fail指针具有的特点：1.从任意节点沿着fail指针遍历，总能回到root节点。2.一个节点的fail指针指向的节点所代表的字符串，为当前节点字符串的某一后缀，因此当匹配时匹配到某一节点时，这一节点fail指针所指向的字符串也一定出现过了，所以在匹配过程中每匹配一个字符，要沿着fail指针跳回root（例如当匹配到abcd时，bcd,cd,d都一定已经出现过了）。3.这个性质与KMP中的next数组很想，可以结合理解。下图是一张构建好的fail指针的图： 查询过程查询步骤：1.如果当前字符匹配，则沿着nxt[id]向下走；如果当前字符不匹配，则沿着fail指针查找nxt[id]直到找到或指向root。2.每匹配完一个字符，沿着fail指针跳回root同时统计路径上出现的单词数。3.将匹配过的模式串打上标记避免重复统计。具体代码如下： 12345678910111213141516171819202122232425int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; //遍历字符串s while(s[i])&#123; //26个小写字母映射到0~25 int id = s[i] - 'a'; //若没有找到nxt[id]且当前指针没有指向root（root的fail指针为NULL），则沿着fail指针遍历直到找到或指向root while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; //若p==NULL，说明最终都没有找到，让p指向root if(p == NULL) p = root; //从p开始跳fail指针统计路径上的单词数 temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; //统计后打上标记（清零单词数量） temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125; 例题+模版hdu2222题意简述：首先输入多个单词（模式串），接着输入一个目标字符串，输出有多少个模式串在目标字符串中出现过。以下为AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;typedef unsigned long long ull;const int P = 1e9+7;const int maxn = 5e5 + 200;const int inf = 0x3f3f3f3f;using namespace std;struct trie&#123; trie *nxt[26]; trie *fail; int cnt; //计算前缀时可用，本题无用 int flag; //记录当前节点结束的字符串个数 trie()&#123; cnt = 1; flag = 0; fail = NULL; memset(nxt,NULL,sizeof(nxt)); &#125;&#125;;trie *root;int T,N,Q;char S[maxn],s1[maxn],s2[maxn];void Insert(char *s)&#123; trie *p = root; int len = strlen(s); for(int i = 0; i &lt; len; i++)&#123; int id = s[i] - 'a'; if(p-&gt;nxt[id] != NULL)&#123; p = p-&gt;nxt[id]; p -&gt; cnt++; &#125; else&#123; p -&gt; nxt[id] = new trie; p = p -&gt; nxt[id]; &#125; &#125; p -&gt; flag++;&#125;void getFail()&#123; queue&lt;trie*&gt; q; q.push(root); trie *temp,*p; while(!q.empty())&#123; p = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i])&#123; if(p == root) p -&gt; nxt[i] -&gt; fail = root; else&#123; temp = p -&gt; fail; while(temp)&#123; if(temp -&gt; nxt[i])&#123; p -&gt; nxt[i] -&gt; fail = temp -&gt; nxt[i]; break; &#125; temp = temp -&gt; fail; &#125; if(!temp) p -&gt; nxt[i] -&gt; fail = root; &#125; q.push(p -&gt; nxt[i]); &#125; &#125; &#125;&#125;int query(char* s)&#123; int i = 0,res = 0; trie *p = root; trie *temp; while(s[i])&#123; int id = s[i] - 'a'; while(!p -&gt; nxt[id] &amp;&amp; p != root) p = p -&gt; fail; p = p -&gt; nxt[id]; if(p == NULL) p = root; temp = p; while(temp != root &amp;&amp; temp -&gt; flag != 0)&#123; res += temp -&gt; flag; temp -&gt; flag = 0; temp = temp -&gt; fail; &#125; i++; &#125; return res;&#125;//递归释放Trievoid Free(trie *p)&#123; for(int i = 0; i &lt; 26; ++i)&#123; if(p -&gt; nxt[i] != NULL) Free(p-&gt;nxt[i]); &#125; delete(p); p = NULL;&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; root = new trie; scanf(\"%d\",&amp;N); while(N--) &#123; scanf(\"%s\",S); Insert(S); &#125; getFail(); scanf(\"%s\",s1); printf(\"%d\\n\",query(s1)); Free(root); &#125;&#125;","tags":[{"name":"kmp","slug":"kmp","permalink":"https://lotusir.github.io/tags/kmp/"},{"name":"Trie","slug":"Trie","permalink":"https://lotusir.github.io/tags/Trie/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://lotusir.github.io/tags/AC自动机/"},{"name":"字符串","slug":"字符串","permalink":"https://lotusir.github.io/tags/字符串/"}]}]